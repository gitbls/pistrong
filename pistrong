#!/usr/bin/python3

""" 
Manage strongswan Certificate Authority (CA) and user certs/keys via the command line
"""
import argparse
import datetime
from email import encoders
from email.mime.base import MIMEBase
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
import json
import os
import pexpect
import pprint
import random
import re
import shlex
import shutil
import smtplib
import socket
import subprocess
import sys
from tempfile import mkdtemp
import termios
from email.mime.text import MIMEText

class pdat:
    def __init__(self):
        self.dbmodified = False
        self.cadirlist = {}
        self.db = {}
        self.dx = {"debug":False}
        self.swandir = self.pswandir = self.certdb = self.certdbak = self.certdbtmp = ""
        self.dnou = self.dx509 = self.dx509ca = self.dx509crl = self.dprivate = self.dp12 = ""
        self.rootca = self.swancertpfx = self.swancertfn = self.swancert = self.swankey = ""
        self.vpncertpfx = self.vpnhostcert = self.vpnhostkey = self.clientcertfmt = self.clientkeyfmt = ""
        self.clientcert = self.clientkey = self.newp12fn = self.newp12 = self.cn = ""
        self.cpackzip = self.tmpdir = ""
        self.fnpdir = "{}/{}"
        self.dconfd = "conf.d"
        self.revokecrl = self.revoketmp = self.hostfqdn = self.shorthost = self.vpnip = self.lxscript = ""

version = "V3.9"
dbversion = "3"

def qdelfile(qfn):
    """
    Silently delete a file. Errors masked.
    """
    try:
        os.remove(qfn)
    except OSError:
        pass

def qdelwild(qdir, qfn):
    """
    Delete files in qdir that match qfn
    """
    for f in os.listdir(qdir):
        if re.search(qfn, f):
            try:
                os.remove(os.path.join(qdir, f))
            except OSError:
                pass
    return
        
def qrename(src, dst):
    """
    Rename the src file to be dst. Errors masked.
    """
    try:
        os.rename(src, dst)
    except OSError:
        pass

def qcopyfile(src, dst, flog):
    """
    Copy src file to dst
    """
    if flog: print("% Copying '{}' to '{}'".format(src, dst))
    shutil.copy(src, dst)

def enofile(fns, emsg):
    msg = emsg if emsg != "" else "? Required file '{}' is missing"
    if not os.path.isfile(fns): perrorexit(msg.format(fns))

def askyn(question):
    """
    Prompt for an answer with the given question.
    Returns True if yes, False if anything else
    """
    yni = input(question).lower()
    if yni != "" and "yes".startswith(yni): return True
    return False

def asktwice(question):
    """
    Prompt for an answer to a question, and if yes, ask "are you sure"
    """
    if askyn("{} [y/N] ".format(question)) and askyn("Are you sure? [y/N] "):
        return True
    return False

def trueorfalse(answer):
    s = answer.lower()   # parser only accepts lower case, just being cautious
    if "yes".startswith(s) or s == "on": return True
    if "no".startswith(s) or s == "off": return False
    perrorexit("? Unrecognized switch value '{}'".format(answer))  #SNH due to parser checking

def isrootordebug(pd, args):
    pd.dx['debug'] = trueorfalse(args.debug) if args.debug else pd.db['config']['debug']['value']
    pd.dx['cmds'] = trueorfalse(args.cmds) if args.cmds else pd.db['config']['cmds']['value']
    if not pd.dx['debug'] and os.geteuid() != 0: perrorexit("? Must be run as root or --debug on")

def which(fname):
    """
    Returns the full path for for the executable if found on PATH
    """
    for path in os.environ["PATH"].split(os.pathsep):
        fullpath = os.path.join(path, fname)
        if os.path.exists(fullpath) and os.access(fullpath, os.X_OK):
            return fullpath
    return None

def decodeutf(utfstring):
    return utfstring.decode('utf-8')

def printutf(utfstring):
    if utfstring != b'': print(utfstring.decode('utf-8'))
    
def dosystem(pd, docmd, doecho=True, pout=True):
    """
    Execute the string as a separate process, pout=display output, doecho=display cmd if --cmd
    Returns the result from subprocess.run, which contains stdout, returncode, etc.
    """
    if pd.dx['cmds'] and doecho: print("[{}]".format(docmd))
    r = subprocess.run(docmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)
    if pout:
        printutf(r.stdout)
        if r.returncode != 0 and r.stderr != b'':
            printutf(r.stderr)
    return r

def isrunning(pd):
    """
    Returns 0 if strongswan service is running
    """
    r = dosystem(pd, "systemctl --quiet is-active {}".format(pd.db['config']['service']['value']), doecho=False, pout=False)
    return r.returncode

def stopifrunning(pd):
    """
    Stops strongswan if it's running, and returns previous running status
    """
    strunning = isrunning(pd)
    if strunning == 0:
        if not pd.dx['debug']:
            print("% Stopping {}".format(pd.db['config']['service']['value']))
            dosystem(pd, "systemctl stop {}".format(pd.db['config']['service']['value']), doecho=False)
        else:
            strunning = 1
    return strunning

def startifwas(pd, running):
    """
if strongswan was running before, as indicated by argument, restart it
    """
    if running == 0:
        if not pd.dx['debug']:
            print("% Starting {}".format(pd.db['config']['service']['value']))
            dosystem(pd, "systemctl start {}".format(pd.db['config']['service']['value']), doecho=False)

def isikeup(pd, ikename):
    ikes = "--ike {}".format(ikename) if ikename != "" else ""
    r = dosystem(pd, "swanctl --list-sas {}".format(ikes), doecho=False, pout=False)
    if "ESTABLISHED" in decodeutf(r.stdout): return True
    return False

def istunnelup(pd, ikename):
    ikes = "--ike {}".format(ikename) if ikename != "" else ""
    r = dosystem(pd, "swanctl --list-sas {}".format(ikes), doecho=False, pout=False)
    if "INSTALLED" in decodeutf(r.stdout): return True
    return False

def killike(pd, ikename, silently):
    r = dosystem(pd, "swanctl --terminate --ike {}".format(ikename), pout=not silently)
    return r.returncode

def perrorexit(emsg):
    """
    Print the message and exit the program
    """
    raise SystemExit(emsg)

def makefilenames(pd, args):
    pd.certdbak = "{}/bak-pistrongdb.json".format(pd.pswandir)
    pd.certdbtmp = "{}/pistrongdb.tmp".format(pd.pswandir)
    pd.dnou = "{}-strongSwan".format(pd.shorthost)
    pd.dx509 = "{}/x509".format(pd.swandir)
    pd.dx509ca = "{}/x509ca".format(pd.swandir)
    pd.dx509crl = "{}/x509crl".format(pd.swandir)
    pd.dprivate = "{}/private".format(pd.swandir)
    pd.dp12 = "{}/p12".format(pd.swandir)
    pd.dconfd = "{}/conf.d".format(pd.swandir)
    pd.rootca = "{} {} Root CA".format(pd.db['config']['rootca']['value'], pd.shorthost)
    pd.swancertpfx = pd.db['config']['swancertpfx']['value'] if args.cacert is None else args.cacert
    pd.swancertfn = "{}CACert.pem".format(pd.swancertpfx)
    pd.swancert = "{}/{}".format(pd.dx509ca, pd.swancertfn)
    pd.swankey = "{}/{}CAKey.pem".format(pd.dprivate, pd.swancertpfx)
    pd.revokecrl = "{}/revoked.der".format(pd.dx509crl)
    pd.revoketmp = "{}/tmprevoked.der".format(pd.dx509crl)
    pd.cadirlist = {pd.dx509:0o755, pd.dx509ca:0o755, pd.dx509crl:0o755, pd.dprivate:0o750, pd.dp12:0o750}
    pd.clientcertfmt = "{}/{}-{}Cert.pem"
    pd.fnpdir = "{}/{}"

def makeclientfnames(pd, args, newkey):
    pd.clientcert = pd.clientcertfmt.format(pd.dx509, newkey, pd.shorthost)
    pd.clientcertfn = "{}-{}Cert.pem".format(newkey, pd.shorthost)
    pd.clientkeyfmt = "{}/{}-{}Key.pem"
    pd.clientkey = pd.clientkeyfmt.format(pd.dprivate, newkey, pd.shorthost)
    pd.clientkeyfn = "{}-{}Key.pem".format(newkey, pd.shorthost)
    pd.newp12fn = "{}-{}.p12".format(newkey, pd.shorthost)
    pd.newp12 = pd.fnpdir.format(pd.dp12, pd.newp12fn) 
    pd.cn = "{}-{}@{}".format(newkey, pd.shorthost, pd.db['config']['cnsuffix']['value'])

def makevpnfns(pd, args):
    pd.vpncertpfx = pd.db['config']['vpncertpfx']['value'] if args.vpncertpfx is None else args.vpncertpfx
    pd.vpnhostcert = "{}/{}-{}VPNCert.pem".format(pd.dx509, pd.vpncertpfx, pd.swancertpfx)
    pd.vpnhostkey = "{}/{}-{}VPNKey.pem".format(pd.dprivate, pd.vpncertpfx, pd.swancertpfx)
    pd.dx['vpnsankey'] = args.vpnsankey if args.vpnsankey else pd.db['config']['vpnsankey']['value']

def checkmailcfg(pd):

    msg = ""
    if pd.db['config']['smtpserver']['value'] == "":
        msg = "--smtpserver"
    if pd.db['config']['smtpusetls']['value']:
        if pd.db['config']['smtpuser']['value'] == "":
            msg = "{} {}".format(msg, "--smtpuser")
        if pd.db['config']['smtppassword']['value'] == "":
            msg = "{} {}".format(msg, "--smtppassword")
    if msg != "": perrorexit("? Email configuration incomplete: {}".format(msg))

def sendmsg(pd, mfrom, mto, msubj, mtext, mattach):
    """
    Send an email message. May still need work on authentication
    """
    mmsg = MIMEMultipart()
    mmsg['From'] = mfrom
    mmsg['To'] = mto
    mmsg['Subject'] = msubj
    mmsg.attach(MIMEText(mtext, 'plain'))
    if mattach != None:
        with open(mattach, 'rb') as attach:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(attach.read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", "attachment; filename={}".format(os.path.basename(mattach)))
        mmsg.attach(part)
    msmtp = smtplib.SMTP(pd.db['config']['smtpserver']['value'], pd.db['config']['smtpport']['value'])
    msmtp.ehlo()
    if pd.db['config']['smtpusetls']['value']:
       msmtp.starttls()
    try:
        msmtp.login(pd.db['config']['smtpuser']['value'], pd.db['config']['smtppassword']['value'])
    except smtplib.SMTPAuthenticationError as err:
        print("? Authentication error logging in to '{}'".format(pd.db['config']['smtpserver']['value']))
        perrorexit(err)
    except smtplib.SMTPException:  # no login needed if "smart host"
        pass
    msmtp.sendmail(mfrom, mto, mmsg.as_string())
    msmtp.quit()

def genrandpwd():
    """
    Generate a 32-character sequence of random letters and numbers
    """
    chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    spwd = ""
    for irand in range(0, 31):
        spwd += random.choice(chars)
    return spwd

def getpwd():
    """
    Get and verify a password from user, with echo off
    """
    pw1 = "no"
    pw2 = "match"
    stdinfd = sys.stdin.fileno()
    oldtcattr = termios.tcgetattr(stdinfd)
    newtcattr = termios.tcgetattr(stdinfd)
    newtcattr[3] = newtcattr[3] & ~termios.ECHO
    termios.tcsetattr(stdinfd, termios.TCSADRAIN, newtcattr)
    try:
        while pw1 != pw2:
            pw1 = input("Enter password: ")
            print("")
            pw2 = input("Verify password: ")
            print("")
            if pw1 != pw2:
                print("% Passwords do not match. Try again.")
    finally:
        termios.tcsetattr(stdinfd, termios.TCSADRAIN, oldtcattr)
    return pw1

def mkpkcs12zpw(pd, pzcmd):
    """
    Make the .p12 file with no password prompts, with a null password
    """
    if pd.dx['cmds']:
        print("[{}]".format(pzcmd))
    child = pexpect.spawn(pzcmd)
    child.expect("Enter Export Password:")
    child.sendline("")
    child.expect("Verifying - Enter Export Password:")
    child.sendline("")
    child.expect(pexpect.EOF)

def reloadcreds(pd):
    """
    If strongswan is running, reload the VPN's credentials
    """
    if isrunning(pd) == 0:
        print("% Reloading strongSwan VPN credentials...")
        dosystem(pd, "swanctl --load-creds")  # reload credentials

def gethostfqdn(pd, args):
    if pd.db['config']['myfqdn']['value'] != "":
        pd.hostfqdn = pd.db['config']['myfqdn']['value']
        pd.shorthost = pd.hostfqdn.split(".")[0]
    else:
        pd.hostfqdn = socket.getfqdn()
        pd.shorthost = pd.hostfqdn.split(".")[0]
        pd.vpnip = socket.gethostbyname(pd.hostfqdn)
        if pd.vpnip.split(".")[0] == "127":
            try:
                s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                s.connect(("8.8.8.8", 80))
                pd.vpnip = s.getsockname()[0]
            except:
                pd.vpnip = "127.0.0.1"  # In case it came out as 127.0.1.1
                print("% Couldn't divine host IP address. Using 127.0.0.1. Check /etc/hosts")
            s.close()

    if pd.hostfqdn == "" and args.myfqdn == None:
        print("% Unable to obtain a fully-qualified domain name for this host\n  This may impact internet accessibility for the VPN\n  Use 'sudo pistrong config --myfqdn' and/or see the pistrong README")

def dbload(pd):
    """
    Read the cert database and build a dictionary
    """
    if os.path.isfile(pd.certdb):
        with open(pd.certdb,'r') as dbf:
            try:
                pd.db = json.load(dbf)
            except ValueError:
                perrorexit("? Database {} has invalid syntax".format(pd.certdb))
    # If a section isn't there, create it. Will be saved later
    if not (('users' in pd.db) and ('config' in pd.db) and ('certs' in pd.db)): pd.dbmodified = True
    if not 'users' in pd.db:
        pd.db['users'] = {}
    if not 'config' in pd.db:
        pd.db['config'] = {"rootca":{"value":"strongSwan","help":"String for root CA name [strongSwan]"},\
                           "swancertpfx":{"value":"strongSwan","help":"CA Cert name prefix [strongSwan]"},
                           "swandir":{"value":"/etc/swanctl", "help":"System directory for strongSwan [/etc/swanctl]"},
                           "vpncertpfx":{"value":"default","help":"VPN Cert name prefix [default]"},\
                           "crllife":{"value":"7","help":"Cert Revocation List lifetime [7 days]"},\
                           "calife":{"value":"3650","help":"CA Lifetime [3650 days]"},\
                           "uclife":{"value":"730","help":"User Cert Lifetime [730 days]"},\
                           "myfqdn":{"value":"","help":"VPN host FQDN (Fully Qualified Domain Name)"},\
                           "version":{"value":"3.0","help":"Database version"},\
                           "validids":{"value":"","help":"Valid SAN Keys"},\
                           "vpnaddr":{"value":"","help":"VPN Server Address (IP or DNS)"},\
                           "vpnsankey":{"value":"ipsec.vpn.net","help":"Default VPN SAN key"},\
                           "cnsuffix":{"value":"ipsec.vpn","help":"Suffix for user cert names"},\
                           "service":{"value":"strongswan.service","help":"strongSwan service name"},\
                           "cmds":{"value":False,"help":"Echo executed commands"},\
                           "lxscript":{"value":"pistrong-vpn-installer","help":"Linux VPN Config Pack script name"},\
                           "debug":{"value":False,"help":"Debug mode"},\
                           "random":{"value":True,"help":"Generate random cert passwords"},\
                           "mailfrom":{"value":"PiStrongVPN<root@mydomain.com>","help":"'From' string for cert email"},\
                           "smtpserver":{"value":"","help":"SMTP mail server IP address or name"},\
                           "smtpport":{"value":"25","help":"SMTP mail server port"},\
                           "smtpuser":{"value":"","help":"SMTP mail server username if required"},\
                           "smtppassword":{"value":"","help":"SMTP mail server password if required"},\
                           "smtpusetls":{"value":False,"help":"SMTP Mail use TLS auth"},\
                           "webdir":{"value":"tmp","help":"Directory in file system corresponding to weburl"},\
                           "weburl":{"value":"http://127.0.0.1","help":"Web URL on which to append cert name"}}
        pd.dbmodified = True
    if not ('version' in pd.db['config']) or (pd.db['config']['version']['value'] < "3"):
            perrorexit("? {} is from a prior version. See documentation".format(pd.certdb))
    #
    # These fixits are for items added to the DB over time. At some point we can be brave
    # and remove them.
    #
    for u in pd.db['users']:
        if not 'linux' in pd.db['users'][u]:
            pd.db['users'][u]['linux'] = False
            pd.dbmodified = True
    pd.db['config']['version']['value'] = dbversion    # Force to current version. Will get written to DB first time a real update is done
    if not 'myfqdn' in pd.db['config']:
        pd.db['config']['myfqdn'] = {"value":"","help":"VPN host Fully Qualified Domain Name"}
        pd.dbmodified = True
    if not 'validids' in pd.db['config']:
        pd.db['config']['validids'] = {"value":"","help":"Valid SAN Keys"}
        pd.dbmodified = True
    if not 'vpnaddr' in pd.db['config']:
        pd.db['config']['vpnaddr'] = {"value":"","help":"VPN Server Address (IP or DNS)"}
        pd.dbmodified = True
    if not 'certs' in pd.db:
        pd.db['certs'] = {}
        pd.dbmodified = True

def keyindb(pd, keyname):
    """
    Return true if key in database, false if not. Separate function for readability
    """
    if keyname in pd.db['users']: return True
    return False

def dbflush(pd):
    """
    Flush the database to disk. Do any time database changes
    """
    qdelfile(pd.certdbtmp)
    with open(pd.certdbtmp, "w") as dbfw:
        json.dump(pd.db, dbfw, indent=4, sort_keys=True)
        dbfw.write("\n") # json.dump doesn't put out a final eol lol
    os.chmod(pd.certdbtmp, 0o600)
    qdelfile(pd.certdbak)
    qrename(pd.certdb, pd.certdbak)
    qrename(pd.certdbtmp, pd.certdb)
    pd.dbmodified = False

def dbupdate(pd, keyname, newstatus, upwd, ca, remoteid, islinux):
    """
    Add a new entry or update entry in database. newstatus=V|R (valid | revoked)
    """
    if not keyname in pd.db['users']:
        pd.db['users'][keyname] = {}
    pd.db['users'][keyname]['ca'] = ca
    pd.db['users'][keyname]['state'] = newstatus
    pd.db['users'][keyname]['date'] = datetime.datetime.strftime(datetime.datetime.now(), "%Y-%m-%d:%H:%M:%S")
    pd.db['users'][keyname]['password'] = upwd
    pd.db['users'][keyname]['remoteid'] = remoteid
    pd.db['users'][keyname]['linux'] = islinux
    dbflush(pd)

def addidtodb(pd, newid):
    if isidvalid(pd, newid): return
    scomma = "" if pd.db['config']['validids']['value'] == "" else ","
    pd.db['config']['validids']['value'] = "{}{}{}".format(pd.db['config']['validids']['value'], scomma, newid)
    pd.dbmodified = True
    return

def isidvalid(pd, thisid):
    if ",{},".format(thisid) in ",{},".format(pd.db['config']['validids']['value']): return True
    return False

def findvalidids(pd):
    for fn in os.listdir(pd.dx509):
        filename = os.fsdecode(fn)
        if filename.endswith("{}VPNCert.pem".format(pd.swancertpfx)):
            sankeys = getcertkey("{}/{}".format(pd.dx509, filename), "altNames:")
            skey = sankeys.split(",")[0].strip()    # The SAN key is always first. FQDN or IP address is second
            addidtodb(pd, skey)
    return

def makekeyname(pd, args):
    """
    Create keyname (username-dev) and check validity
    """
    newkey = args.username if args.username != None else ""
    devname = "dev" if args.device is None else args.device
    if newkey != "" and not "-" in newkey: newkey = "{}-{}".format(newkey, devname)
    if " " in newkey: perrorexit("? Space not allowed in user name")
    return newkey

def getcertkey(certfile, keyname):
    """
    Returns the specified "keyname:" from a cert in readable format
    """
    acert = subprocess.check_output(("pki --print --type x509 --in {}".format(certfile)), shell=True)
    for line in decodeutf(acert).split("\n"):
        if keyname in line:
            return line.replace(keyname,"").strip()
    return ""

def maxcacertname(pd):
    maxnam = 0
    for fn in pd.db['certs']:
        maxnam = max(maxnam, len(fn))
    return maxnam

def maxvpncertname(pd):
    """
    Find the longest VPN cert name
    """
    maxnam = 0
    for fn in os.listdir(pd.dx509):
        if fn.endswith("VPNCert.pem"):
            maxnam = max(maxnam, len(os.fsdecode(fn))-len("VPNCert.pem"))
    return maxnam

def maxremoteid(pd):
    """
    Find the longest remoteid for listing users
    """
    maxr = 0
    for ukey in pd.db['users']:
        maxr = max(maxr, len(pd.db['users'][ukey]['remoteid']))
    return maxr
    
def listentry(pd, listkey, maxkey, maxcertlen, maxrid):
    """
    Print the information for a key. If --full, print the cert as well
    """
    listcert = pd.clientcertfmt.format(pd.dx509, listkey, pd.shorthost)
    sx = "*" if pd.db['users'][listkey]['linux'] else " "
    listkeyname = "{}{}".format(listkey, sx)
    print("{sts}       {key:<{wid}} {date} {caname:<{cawid}} {remid:<{rmax}} {password}".format(sts=pd.db['users'][listkey]['state'],\
                                                              key=listkeyname, wid=maxkey,\
                                                              date=pd.db['users'][listkey]['date'],\
                                                              caname=pd.db['users'][listkey]['ca'], cawid=maxcertlen,\
                                                              remid=pd.db['users'][listkey]['remoteid'],  rmax=maxrid,\
                                                              password=pd.db['users'][listkey]['password']))
    if args.full:
        if os.path.isfile(listcert):
            acert = subprocess.check_output(("pki --print --type x509 --in {}".format(listcert)), shell=True)
            for line in decodeutf(acert).split("\n"):
                if line != "":
                    print(line)
        else:
            print("% Cert '{}' for user '{}' not found".format(listcert, listkey))
        print("")

def listentries(pd, estatus, keyname, maxkey, maxcertlen, maxrid):
    """
    List a set of selected entries
    """
    for listkey in sorted(pd.db['users']):
        if estatus == pd.db['users'][listkey]['state']:
            if keyname == "":
                listentry(pd, listkey, maxkey, maxcertlen, maxrid)
            else:
                if listkey.split("-")[0] == keyname:
                    listentry(pd, listkey, maxkey, maxcertlen, maxrid)


def findclientvpn(pd, args, vpnkey):
    found = []
    for file in os.listdir("{}/VPNClients".format(pd.pswandir)):
        filename = os.fsdecode(file)
        if filename.startswith(vpnkey):
            found.append(filename)
    return found
            
def certdetailmsg(pd, args, newkey, tfmail):
    # tfmail = true if sending in email, false if into a zip file
    msg =  "See https://github.com/gitbls/pistrong/blob/master/CertInstall.md\n"
    msg += "for detailed certificate installation instructions\n\n"
    msg += "Conection Details:\n"
    msg += "   Server:      {}\n   Remote ID:   {}\n   Local ID:    {}\n".format(pd.dx['vpnaddr'], pd.db['users'][newkey]['remoteid'], pd.cn)
    msg += "   Cert Name:   {}\n\n".format(pd.cn)
    if pd.db['users'][newkey]['password'] == "":
        msg += "\nThis certificate does not have a password\n"
    else:
        if tfmail:
            msg += "\nThe password for this VPN Device Cert is in a separate email message\n"
        else:
            msg += "\nAsk the VPN administrator for the VPN Device Cert password if you do not have it\n"
    return msg

def makeuserzip(pd, args, newkey):
    pd.cpackzip = "{}/server-assets/{}.zip".format(pd.pswandir, newkey)
    pd.tmpdir = mkdtemp(prefix="pistrong")
    tmpf = "{}/{}".format(pd.tmpdir, "readme.txt")
    with open(tmpf, 'w') as f:
        f.write(certdetailmsg(pd, args, newkey, False))
    dosystem(pd, "zip -jq {} {} {} {}".format(pd.cpackzip, pd.swancert, pd.newp12, tmpf))
    os.unlink(tmpf)
    os.rmdir(pd.tmpdir)

def buildlinuxpack(pd, args, newkey, newremoteid):
    pd.cpackzip = "{}/server-assets/{}.zip".format(pd.pswandir, newkey)
    pd.tmpdir = mkdtemp(prefix="pistrong")
    # Make a copy of the CA cert and rename it to {hostname}-{name}CACert.pem
    # so that the client can have CA Cert files from multiple hosts
    qcopyfile(pd.swancert, pd.tmpdir, False)
    tmpswancert = "{}/{}-{}".format(pd.tmpdir, pd.shorthost, pd.swancertfn)
    tmpswancertfn="{}-{}".format(pd.shorthost, pd.swancertfn)
    qrename(pd.fnpdir.format(pd.tmpdir,pd.swancertfn), tmpswancert)
    # Create the zip file and put the certs into it
    dosystem(pd, "zip -jq {} {} {} {}".format(pd.cpackzip, tmpswancert, pd.clientcert, pd.clientkey))
    # Build the installer script and add to the zip file
    tmpf = "{}/{}".format(pd.tmpdir, pd.db['config']['lxscript']['value'])
    with open(tmpf, 'w') as f:
        hypfqdn = pd.dx['cname']
        f.write("#!/bin/bash\n")
        f.write("# pistrong {} Linux VPN Configuration Installer\n".format(version))
        f.write("# Built on Host {} for {} at {}\n".format(pd.hostfqdn, newkey, datetime.datetime.strftime(datetime.datetime.now(), "%Y%m%d-%H%M%S")))
        f.write("zf=$1\n")
        f.write("zfn=$(basename $zf)\n")
        f.write("swandir=${2:-/etc/swanctl}\n")
        f.write("cd $swandir\n")
        f.write("unzip -d  $swandir/x509ca  $zf {}\n".format(tmpswancertfn))
        f.write("unzip -d  $swandir/x509    $zf {}\n".format(pd.clientcertfn))
        f.write("unzip -d  $swandir/private $zf {}\n".format(pd.clientkeyfn))
        f.write("chmod 755 $swandir/x509ca/{}\n".format(tmpswancertfn))
        f.write("chmod 755 $swandir/x509/{}\n".format(pd.clientcertfn))
        f.write("chmod 600 $swandir/private/{}\n".format(pd.clientkeyfn))
        f.write("updowns='/usr/lib/ipsec/_updown'\n")
        # If $updowns not found we were built from tarball, so use alternate location
        f.write('[ ! -f $updowns ] && updowns="/libexec/ipsec/_updown"\n')
        f.write("cat > $swandir/conf.d/{}-ClientConnection.conf <<EOF\n".format(pd.hostfqdn))
        f.write("connections {\n")
        f.write("    {} {{\n".format(hypfqdn))
        f.write("        version = 2\n")
        f.write("        remote_addrs = {}\n".format(pd.dx['vpnaddr']))
        f.write("        local_addrs  = %any\n")
        f.write("        vips = 0.0.0.0\n")
        f.write("        mobike = yes\n")
        f.write("        reauth_time = 10800\n\n")
        f.write("        local-1 {\n")
        f.write("            auth = pubkey\n")
        f.write("            certs = {}\n".format(pd.clientcert))
        f.write("            id = {}\n".format(pd.cn))
        f.write("        }\n\n")
        f.write("        remote-1 {\n")
        f.write("            id = {}\n".format(newremoteid))
        f.write("        }\n")
        f.write("        children {\n")
        f.write("            {} {{\n".format(hypfqdn))
        f.write("                local_ts = 0.0.0.0/0\n")
        f.write("                remote_ts = 0.0.0.0/0\n")
        f.write("                updown = $updowns iptables\n")
        f.write("                esp_proposals = aes128gcm128-x25519\n")
        f.write("            }\n")
        f.write("        }\n")
        f.write("    }\n")
        f.write("}\n")
        f.write("EOF\n")
        f.write("cat > $swandir/pistrong/VPNClients/{} <<EOF\n".format(pd.hostfqdn))
        f.write("# Client VPN {} connection assets\n".format(pd.hostfqdn))
        f.write("conn={}\n".format(hypfqdn))
        f.write("vpnaddr={}\n".format(pd.dx['vpnaddr']))
        f.write("file=private/{}\n".format(pd.clientkeyfn))
        f.write("file=x509/{}\n".format(pd.clientcertfn))
        f.write("file=x509ca/{}\n".format(tmpswancertfn))
        f.write("file=conf.d/{}-ClientConnection.conf\n".format(pd.hostfqdn))
        f.write("file=pistrong/client-assets/$zfn\n")
        f.write("EOF\n")
        f.write("cp $zf $swandir/pistrong/client-assets\n")
        f.write('echo ""\n')
        f.write('echo "The name of this connection is \'{}\'"\n'.format(pd.hostfqdn))
        f.write('echo ""\n')
        f.write('echo "Please sudo systemctl restart strongswan to enable new VPN connection"\n')
        f.write('echo ""\n')
        f.write('echo "\nUse the \'sudo pistrong client\' command to manage the client VPN:"\n')
        f.write("pistrong client --help\n")
        f.write('echo ""\n')
        f.write('echo "For instance use sudo \'pistrong client start {}\' to start the VPN connection"\n'.format(pd.hostfqdn))
        f.write('echo ""\n')
    dosystem(pd, "zip -jq {} {}".format(pd.cpackzip, tmpf))
    os.unlink(tmpf)
    os.unlink(tmpswancert)
    os.rmdir(pd.tmpdir)

def mailcert(pd, args, newkey):
    if pd.db['users'][newkey]['linux']:
        if not args.zip:
            zipfn = "{}.zip".format(newkey)
            qcopyfile("{}/server-assets/{}".format(pd.pswandir, zipfn), pd.dx['webdir'], True)
            webfn = pd.fnpdir.format(pd.dx['webdir'],"{}".format(zipfn))
            os.chmod(webfn, 0o644)
        msg = "\nDownload this VPN Config Pack to your Linux VPN client system\n\nUse 'sudo pistrong client install <zipfile>' to install\n"
        if not args.zip: msg += "\n  {}\n\n".format(pd.fnpdir.format(pd.dx['weburl'], zipfn))
        msg += "\nThis Linux VPN Config Pack does not have a password"
        zfl = pd.cpackzip if args.zip else None
        sendmsg(pd, pd.dx['mailfrom'], args.mail, "VPN Cert {}".format(pd.cn), msg, zfl)
    else:
        if args.zip:
            msg = "Your VPN Certificates are in the attached zip file\n\n"
            zipfile = pd.cpackzip
        else:
            zipfile = None
            webfn = pd.fnpdir.format(pd.dx['webdir'], pd.newp12fn)
            qcopyfile(pd.newp12, webfn, True)
            os.chmod(webfn, 0o644)
            webfn = pd.fnpdir.format(pd.dx['webdir'], pd.swancertfn)
            qcopyfile(pd.swancert, webfn, True)
            os.chmod(webfn, 0o644)
            certurl = pd.fnpdir.format(pd.dx['weburl'], pd.newp12fn)
            cacerturl = pd.fnpdir.format(pd.dx['weburl'], pd.swancertfn)
            msg = "VPN Certificates\n----------------\nRoot CA Cert:             {}\nYour Device Certificate:  {}\n\n".format(cacerturl, certurl)
        msg += certdetailmsg(pd, args, newkey, True)
        if pd.db['users'][newkey]['password'] != "":
            pwmsg = "Use this password to import the certificate onto your device:\n\n{}\n".format(pd.db['users'][newkey]['password'])
            sendmsg(pd, pd.dx['mailfrom'], args.mail, "VPN Cert password {}".format(pd.cn), pwmsg, None)
        sendmsg(pd, pd.dx['mailfrom'], args.mail, "VPN Cert {}".format(pd.cn), msg, zipfile)
    print("% Mail sent to '{}'".format(args.mail))

def makevpncert(pd, args):
    """
    Make a VPN cert
    """
    newskey = pd.dx['vpnsankey'].split(",")[0].strip()    # The SAN key is always first. FQDN or IP address is second
    if isidvalid(pd, newskey):
        perrorexit("? SAN Key '{}' is already configured in this CA; See sudo pistrong listca".format(newskey))
    print("Create VPN Host Key  ({})".format(pd.vpnhostkey))
    dosystem(pd, "pki --gen --type rsa --size {} --outform pem > {}".format(args.keybits, pd.vpnhostkey))
    os.chmod(pd.vpnhostkey, 0o600)
    print("Create VPN Host Cert ({})".format(pd.vpnhostcert))
    print(" with VPN SAN key(s) {}\n".format(pd.dx['vpnsankey']))
    sankey = pd.dx['vpnsankey']
    sanstring = ""
    for iakey in sankey.split(","):
            sanstring += " --san {}".format(iakey.strip())
    cacmd = "pki --issue --in {} --type rsa --lifetime {} --cacert {} --cakey {} --dn \"C=US, O={}, CN={}\"{} --flag serverAuth --flag ikeIntermediate --outform pem > {}".format(pd.vpnhostkey, pd.db['config']['calife']['value'], pd.swancert, pd.swankey, pd.dnou, pd.hostfqdn, sanstring, pd.vpnhostcert)
    dosystem(pd, cacmd)
    dosystem(pd, "pki --print --in {}".format(pd.vpnhostcert))
    addidtodb(pd, newskey)

def makecacert(pd, args):
    """
    """
    print("Creating CA Key ({})".format(pd.swankey))
    dosystem(pd, "pki --gen --type rsa --size {} --outform pem > {}".format(args.keybits, pd.swankey))
    os.chmod(pd.swankey, 0o600)
    print("Create self-signed CA Cert ({})\n".format(pd.swancert))
    dosystem(pd, "pki --self --ca --lifetime {} --in {} --type rsa\
    --dn \"C=US, O={}, CN={}\" --outform pem > {}".format(pd.db['config']['calife']['value'], pd.swankey, pd.dnou, pd.rootca, pd.swancert))
    dosystem(pd, "pki --print --in {}".format(pd.swancert))
    pd.db['certs'][pd.swancertpfx.replace(".pem","")] = getcertkey(pd.swancert, "subjkey:")
    pd.dbmodified = True

def checkcaexist(pd):
    enofile(pd.swancert, "% CA file '{}' not found")
    enofile(pd.swankey, "% CA file '{}' not found")


def makeca(pd, args):
    """
    Make the Certificate Authority (CA)
    """
    print("Creating strongSwan CA for host {} in {}".format(pd.hostfqdn, pd.swandir))
    makecacert(pd, args)
    if not args.novpncert: makevpncert(pd, args)
    pd.dbmodified = True

def listconfig(pd, args):
    maxval = 0
    for i in pd.db['config']:
        ilen = len(pd.db['config'][i]['value']) if type(pd.db['config'][i]['value']) is str else 5
        maxval = max(maxval, ilen)
    print("{ck:<15} {val:<{vwid}} {help}".format(ck="Config Key", val="Value", help="Description", vwid=maxval))
    for i in sorted(pd.db['config']):
        print("{key:<15} {val:<{vwid}} {help}".format(key=i, val=pd.db['config'][i]['value'], help=pd.db['config'][i]['help'], vwid=maxval))
    
def doconfigitem(pd, dest, argval, tfitem=False):
    # If arg was specified on command line, set it into the configuration and set dbmodified
    # if tfitem=True set the value to trueorfalse(argval)
    if argval != None:
        pd.db['config'][dest]['value'] = argval if not tfitem else trueorfalse(argval)
        pd.dbmodified = True

def cmd_config(pd, args):
    doconfigitem(pd, 'cacert', args.cacert)
    doconfigitem(pd, 'calife', args.calife)
    doconfigitem(pd, 'cmds', args.cmds, tfitem=True)
    doconfigitem(pd, 'cnsuffix', args.cnsuffix)
    doconfigitem(pd, 'crllife', args.crllife)
    doconfigitem(pd, 'debug', args.debug, tfitem=True)
    doconfigitem(pd, 'mailfrom', args.mailfrom)
    doconfigitem(pd, 'myfqdn', args.myfqdn)
    doconfigitem(pd, 'random', args.random, tfitem=True)
    doconfigitem(pd, 'rootca', args.rootca)
    doconfigitem(pd, 'service', args.service)
#    if args.smtppassword != None: doconfigitem(pd, 'smtppassword', args.smtppassword)
    doconfigitem(pd, 'smtppassword', args.smtppassword)
    doconfigitem(pd, 'smtpport', args.smtpport)
    doconfigitem(pd, 'smtpserver', args.smtpserver)
    doconfigitem(pd, 'smtpuser', args.smtpuser)
    doconfigitem(pd, 'smtpusetls', args.smtpusetls, tfitem=True)
    doconfigitem(pd, 'swancertpfx', args.swancertpfx)
    doconfigitem(pd, 'uclife', args.uclife)
    doconfigitem(pd, 'vpnaddr', args.vpnaddr)
    doconfigitem(pd, 'vpncertpfx', args.vpncertpfx)
    doconfigitem(pd, 'vpnsankey', args.vpnsankey)
    doconfigitem(pd, 'webdir', args.webdir)
    doconfigitem(pd, 'weburl', args.weburl)
    # Show config if --list or no config file exists yet (we'll write at end of this command)
    if args.list or not pd.dbmodified or (pd.dbmodified and not os.path.isfile(pd.certdb)): listconfig(pd, args)
    return

def cmd_add(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    if newkey == "":
        perrorexit("? No user name specified")
    checkcaexist(pd)
    makeclientfnames(pd, args, newkey)
    pd.dx['random'] = trueorfalse(args.random) if args.random else pd.db['config']['random']['value']
    pd.dx['uclife'] = args.uclife if args.uclife else pd.db['config']['uclife']['value']
    if args.mail != None and not args.zip:
        webvpndir = args.webdir if args.webdir != None else pd.db['config']['webdir']['value']
        if not os.path.exists(webvpndir):
            perrorexit("? Directory '{}' does not exist\n  Please correct or use --zip to mail the zip file\n  or change using 'sudo pistrong config --webdir'".format(webvpndir))
#? Checking wrong directory (need to check args.webdir and pd.db[webdir]
#?    if args.mail != None and not os.path.exists("/var/www/html/vpn"):
#?        perrorexit("? Directory /var/www/html/vpn does not exist\n  Use 'sudo mkdir -p /var/www/html/vpn' to correct")
    if keyindb(pd, newkey):
        perrorexit("? Key '{}' already in use".format(newkey))
    ipwd = "" if args.password is None else args.password
    if not args.nopass:
        if pd.dx['random'] and ipwd == "":
            ipwd = genrandpwd()
        if ipwd == "":
            ipwd = getpwd()
    newremoteid = pd.db['config']['vpnsankey']['value'].split(',')[0] if args.remoteid is None else args.remoteid
    if not isidvalid(pd, newremoteid):
        perrorexit("? Remote ID '{}' is not configured on this VPN".format(newremoteid))
    if ((args.ios and args.linux) or (args.ios and args.windows) or (args.linux and args.windows)):
        perrorexit("? Only one of --ios, --windows, or --linux can be specified")
    checkmailcfg(pd)
    pd.dx['vpnaddr'] = pd.db['config']['vpnaddr']['value'] if args.vpnaddr is None else args.vpnaddr
    pd.dx['cname'] = pd.hostfqdn.replace(".","-") if args.cname is None else args.cname.replace(".","-")
    cmd = "pki --gen --type rsa --size {} --outform pem > {}".format(args.keybits, pd.clientkey)
    dosystem(pd, cmd)
    os.chmod(pd.clientkey, 0o600)
    cmd = "pki --issue --in {} --type rsa --lifetime {} --cacert {} --cakey {}".format(pd.clientkey, pd.dx['uclife'], pd.swancert, pd.swankey)
    cmd += " --dn \"C=US, O={}, CN={}\" --san {} --outform pem > {}".format(pd.dnou, pd.cn, pd.cn, pd.clientcert)
    dosystem(pd, cmd)
    cmd = "openssl pkcs12 -export -inkey {}".format(pd.clientkey)
    cmd += " -in {} -name \"{}-{} VPN Certificate\"".format(pd.clientcert, newkey, pd.shorthost)
    cmd += " -certfile {} -caname \"{}\"  -out {}".format(pd.swancert, pd.rootca, pd.newp12)
    if ipwd != "":
        cmd += " -passout pass:{}".format(ipwd)
        dosystem(pd, cmd)
    else:
        mkpkcs12zpw(pd, cmd)
    dbupdate(pd, newkey, "V", ipwd, pd.swancertpfx, newremoteid, args.linux)
    if args.linux:
        buildlinuxpack(pd, args, newkey, newremoteid)
#        print("% Linux VPN Config Pack for '{}' is in '{}'".format(newkey, pd.cpackzip))
        print("% Linux VPN Config Pack '{}' created for '{}'".format(pd.cpackzip, newkey))
    else:
        makeuserzip(pd, args, newkey)
        print("% Zip file '{}' created for '{}'".format(pd.cpackzip, newkey))
    if args.mail != None:
        pd.dx['mailfrom'] = pd.db['config']['mailfrom']['value']
        pd.dx['webdir'] = args.webdir if args.webdir != None else pd.db['config']['webdir']['value']
        pd.dx['weburl'] = args.weburl if args.weburl != None else pd.db['config']['weburl']['value']
        mailcert(pd, args, newkey)
    print("% Added '{}' with Remote ID '{}' using CA Cert '{}'".format(newkey, newremoteid, pd.swancertpfx))
#    if args.linux and args.mail == None:
#        print("% Linux VPN Config Pack for '{}' is in '{}'".format(newkey, pd.cpackzip))
    return

def cmd_delete(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    makeclientfnames(pd, args, newkey)
    checkcaexist(pd)
    if keyindb(pd, newkey):
        del pd.db['users'][newkey]
        dbflush(pd)
        print("% User cert '{}' deleted".format(newkey))
        qdelfile(pd.clientcert)
        qdelfile(pd.clientkey)
        qdelfile(pd.newp12)
    else:
        print("% User '{}' not found".format(newkey))
    return

def cmd_revoke(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    makeclientfnames(pd, args, newkey)
    checkcaexist(pd)
    if not keyindb(pd, newkey):
        perrorexit("? User cert '{}' not found".format(newkey))
    if not os.path.isfile(pd.clientcert):
        perrorexit("? Cert '{}' for user '{}' not found".format(pd.clientcert, newkey))
    lastcrl = "--lastcrl {}".format(pd.revokecrl) if os.path.isfile(pd.revokecrl) else ""
    cmd = "pki --signcrl --cacert {} --cakey {}".format(pd.swancert, pd.swankey)
    cmd += " --reason superseded --lifetime {} --cert {} {} > {}".format(pd.db['config']['crllife']['value'], pd.clientcert, pd.lastcrl, pd.revoketmp)
    dosystem(pd, cmd)
    qdelfile(pd.revokecrl)
    qrename(pd.revoketmp, pd.revokecrl)
    dbupdate(pd, newkey, "R", "", "", pd.db['users'][newkey]['linux'])
    print("% User '{}' revoked".format(newkey))
    print("% Use 'sudo pistrong delete {}' to delete user's certs/keys when ready".format(newkey))
    return

def cmd_resend(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    makeclientfnames(pd, args, newkey)
    checkcaexist(pd)
    if args.mail is None: perrorexit("? Resend command requires --mail to specify email address")
    checkmailcfg(pd)
    if keyindb(pd, newkey):
        pd.dx['mailfrom'] = pd.db['config']['mailfrom']['value']
        pd.dx['webdir'] =   pd.db['config']['webdir']['value']
        pd.dx['weburl'] =   pd.db['config']['weburl']['value']
        pd.cpackzip = "{}/server-assets/{}.zip".format(pd.pswandir, newkey)
        mailcert(pd, args, newkey)
    else:
        perrorexit("? User '{}' not found".format(newkey))
    return

def cmd_list(pd, args):
    isrootordebug(pd, args)
    checkcaexist(pd)
    maxnam = 0
    maxcert = maxcacertname(pd)
    maxrid = max (maxremoteid(pd), len("Remote ID"))
    newkey = "" if args.username == None else makekeyname(pd, args)
    if newkey == "":
        for ukey in pd.db['users']:
            maxnam = max(maxnam, max(len(ukey), len("Key name ")))
        maxnam += 1     # make room for Linux client flag (or space)
        if not args.full:
            print("Status  {key:<{wid}} {date:<20}{cacert:<{camax}} {remid:<{rmax}} Password".format(wid=maxnam, key="Key name", cacert="CA", camax=maxcert, date="Date", remid="Remote ID", rmax=maxrid))
        listentries(pd, "V", "", maxnam, maxcert, maxrid)
        listentries(pd, "R", "", maxnam, maxcert, maxrid)
    else:
        if args.all:
            for ukey in pd.db['users']:
                if ukey.split("-")[0] == args.username:
                    maxnam = max(maxnam, len(ukey))
                    maxnam += 1 # make room for Linux client flag (or space)
                # List valid entries, then revoked entries
            listentries(pd, "V", args.username, maxnam, maxcert, maxrid)
            listentries(pd, "R", args.username, maxnam, maxcert, maxrid)
        else:
            if keyindb(pd, newkey):
                listentry(pd, newkey, len(newkey), maxcert, maxrid)
            else:
                print("? User '{}' not found".format(newkey))

    return

def cmd_createca(pd, args):
    """
    makeca command execution
    """
    isrootordebug(pd, args)
    for cadir in pd.cadirlist:
        if not os.path.isdir(cadir): os.mkdir(cadir, pd.cadirlist[cadir])
    if os.path.isfile(pd.swancert):
        perrorexit("? There is already a CA in this directory\n% Use 'pistrong deleteca' first")
    sts = stopifrunning(pd)
    makevpnfns(pd, args)
    if args.novpncert or (pd.dx['vpnsankey'] != "ipsec.vpn.net"):
        makeca(pd, args)
        if not args.nocamsg:
            print("% CA created in {}".format(pd.swandir))
    else:
        perrorexit("? You must specify --vpnsankey with other than the default 'ipsec.vpn.net'")
    return

def cmd_deleteca(pd, args):
    """
    Deletes the CA. Everything.
    """
    isrootordebug(pd, args)
    print("% WARNING: This will delete all CA and user certs and all keys in {}".format(pd.swandir))
    if asktwice("Do you want to continue?"):
        stopifrunning(pd)
        qdelfile("{}/pistrong-CAServerConnection.conf".format(pd.dconfd))
        for cadir in pd.cadirlist:
            shutil.rmtree(cadir, ignore_errors=True)
            if not os.path.isdir(cadir): os.mkdir(cadir, pd.cadirlist[cadir])
        qdelwild(pd.pswandir, "Tunnel.*\.iptables$")
        qdelwild(pd.dconfd, "Tunnel.*\.conf$")
        qdelwild(pd.dconfd, ".*ClientConnection.conf$")
        qdelwild("{}/server-assets".format(pd.pswandir), ".*\.zip$")
        qdelwild("{}/client-assets".format(pd.pswandir), ".*\.zip$")
        qdelwild("{}/VPNClients".format(pd.pswandir), ".*$")
        pd.db['users'] = {}    # Delete all the users and flush certdb
        pd.db['certs'] = {}
        pd.db['config']['validids']['value'] = ""
        dbflush(pd)
        print("% CA Deleted. pistrong configuration (/etc/swanctl/pistrong/pistrongdb.json) retained")
    else:
        print("% CA NOT deleted")
    return

def cmd_makevpncert(pd, args):
    """
    Make a new VPN cert command. pistrong makevpncert --vpncert MyCert makes MyCertVPNCert/MyCertVPNKey
    """
    isrootordebug(pd, args)
    checkcaexist(pd)
    makevpnfns(pd, args)
    if os.path.isfile(pd.vpnhostcert) or os.path.isfile(pd.vpnhostkey):
        perrorexit("? VPN Host Cert {} and/or VPN Host Key {} already exist".format(pd.vpnhostcert, pd.vpnhostkey))
    makevpncert(pd, args)
    return

def cmd_makecacert(pd, args):
    """
    Make an additional CA Cert/Key
    """
    isrootordebug(pd, args)
    if os.path.isfile(pd.swancert) or os.path.isfile(pd.swankey):
        perrorexit("? CA Cert {} or CA Key {} already exist".format(pd.swancert, pd.swankey))
    makecacert(pd, args)
    return

def cmd_showcert(pd, args):
    isrootordebug(pd, args)
    if os.path.isfile(args.certname):
        print("[Certificate {}]".format(args.certname))
        dosystem(pd, "pki --print --in {}".format(args.certname))
    else:
        perrorexit("? Certificate {} not found".format(args.certname))
    return

def cmd_showca(pd, args):
    isrootordebug(pd, args)
    checkcaexist(pd)
    print("[CA Certificate {}]".format(pd.swancert))
    dosystem(pd, "pki --print --in {}".format(pd.swancert))
    for fn in os.listdir(pd.dx509):
        filename = os.fsdecode(fn)
        if filename.endswith("{}VPNCert.pem".format(pd.swancertpfx)):
            print("\n[VPN Host Certificate {}]".format("{}/{}".format(pd.dx509, filename)))
            dosystem(pd, "pki --print --in {}".format(format("{}/{}".format(pd.dx509, filename))))
    if os.path.isfile(pd.revokecrl):
        print("\n[Revoked CRL {}]".format(pd.revokecrl))
        dosystem(pd, "pki --print --in {} --type crl".format(pd.revokecrl))

    return

def cmd_listca(pd, args):
    isrootordebug(pd, args)
    checkcaexist(pd)
    maxnam = maxcacertname(pd)
    maxvpncert = maxvpncertname(pd)
    if maxnam <= 0: return    # no CA files found
    print("\n{h1:<{mx1}}      {h2}".format(h1="Cert Name", mx1=maxnam, h2="CA Cert Subject Key"))
    for cacertfn in sorted(pd.db['certs']):
        print(" CA {cfn:<{mx1}}  {skey}".format(mx1=maxnam, cfn=cacertfn, skey=pd.db['certs'][cacertfn]))
        caname = cacertfn.replace("CACert", "")
        for fn2 in os.listdir(pd.dx509):
            filename = os.fsdecode(fn2)
            if filename.endswith("{}VPNCert.pem".format(caname)):
                print("  VPN {cfn:<{mx1}} SAN: {skey}".format(mx1=maxvpncert, cfn=filename.replace("VPNCert.pem",""), skey=getcertkey("{}/{}".format(pd.dx509,fn2), "altNames:")))
    return

def cmd_service(pd, args):
    isrootordebug(pd, args)
    if os.geteuid() == 0:
        if args.action == "reload":
            reloadcreds(pd)
        else:
            dosystem(pd, "systemctl {} {}".format(args.action, pd.db['config']['service']['value']), doecho=False)
    return

def cmd_client_start(pd, args):
    if args.vpnorzip == None: perrorexit("? Must specify a VPN name")
    vpnkey = args.vpnorzip
    vpnclients = findclientvpn(pd, args, vpnkey)
    if len(vpnclients) == 0: perrorexit("? No matching Client VPN configuration found")
    if len(vpnclients) > 1: perrorexit("? More than one Client VPN configuration matches")
    dvpn = vpnclients[0].replace(".","-")   # Read from connection file someday?
    if isrunning(pd) != 0: perrorexit("? strongSwan not running\n  Use 'sudo systemctl start {} to start it".format(pd.db['config']['service']['value']))
    if isikeup(pd, ""): perrorexit("? VPN already started\n  Use 'sudo pistrong client stop' to stop VPN first")
    waitsec = args.wait
    try:
        subp = subprocess.run(shlex.split("swanctl --initiate --ike {} --child {}".format(dvpn, dvpn)), timeout=int(waitsec), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except subprocess.TimeoutExpired:
        killike(pd, dvpn, True)
        print("? VPN IKE connection timed out after {} seconds".format(waitsec))
        print("  Check remote strongSwan Server, internet connection, and router port forwards for ports 500 and 4500")
#        printutf(subp.stderr) # if swanctl fails, subp isn't set. :(
        return
    printutf(subp.stdout)
    printutf(subp.stderr)
    return

def cmd_client_stop(pd, args):
    r = dosystem(pd, "swanctl --list-sas")
    ikename = (decodeutf(r.stdout).split("\n")[0]).split(':')[0]
    if isikeup(pd, ikename): killike(pd, ikename, False)
    return

def cmd_client_install(pd, args):
    # NOTE: This is security hole if given a rogue "infected" script
    #       For now give installer option to back out after viewing script
    #       Needs work
    if args.vpnorzip == None: perrorexit("? Full path to VPN Config Pack zip file required")
    if not os.path.isfile(args.vpnorzip): perrorexit("? Cannot find VPN Config Pack '{}'".format(args.vpnorzip))
    pd.tmpdir = mkdtemp(prefix="pistrong")
    dosystem(pd, "unzip -d {} {} {}".format(pd.tmpdir, args.vpnorzip, pd.db['config']['lxscript']['value']))
    ufn = pd.fnpdir.format(pd.tmpdir,pd.db['config']['lxscript']['value'])
    os.chmod(ufn, 0o755)
    askyn("\nPress Return when you are ready to review the Client VPN install script: ")
    dosystem(pd, "cat {}".format(ufn), doecho=False)
    if askyn("Do you want to install this VPN Connection? "):
        dosystem(pd, "/bin/bash {} {}".format(ufn, os.path.realpath(args.vpnorzip)), doecho=False)
    return

def cmd_client_status(pd, args):
    r = dosystem(pd, "swanctl --list-sas")
    return r.returncode

def cmd_client_list(pd, args):
    for file in os.listdir("{}/VPNClients".format(pd.pswandir)):
        filename = os.fsdecode(file)
        print(" {}".format(filename))
        
def cmd_client_delete(pd, args):
    vpnkey = args.vpnorzip
    if vpnkey == None: perrorexit("? No Client VPN specified")
    vpnclients = findclientvpn(pd, args, vpnkey)
    if len(vpnclients) == 0: perrorexit("? No matching Client VPN configuration found")
    if len(vpnclients) > 1: perrorexit("? More than one Client VPN configuration matches")
    dvpn = vpnclients[0]
    if vpnkey != dvpn: perrorexit("? Client VPN name must match exactly")
    if askyn("Do you want to delete Client VPN configuration '{}'? ".format(dvpn)):
        vpnconfig = "{}/VPNClients/{}".format(pd.pswandir, dvpn)
        with open(vpnconfig, 'r') as f:
            for line in f:
                if not line.startswith('#'):
                    wds = line.split("=")
                    if wds[0] == "file":
                        tfn = "{}/{}".format(pd.swandir, wds[1].strip())
                        qdelfile(tfn)
        qdelfile(vpnconfig)
        print("% Client VPN '{}' configuration deleted".format(dvpn))
    return

def cmd_client(pd, args):
    client_cmd_actions[args.action][0](pd, args)
    return

def cmd_help(pd, args):
    helpmsg = "pistrong {} commands:\n\
\n\
        * Manage user certs *\n\
 add    name    Create a new user/device cert\n\
 resend name    Resend cert info to user\n\
 list   [name]  List users (see examples)\n\
 revoke name    Revoke user's cert\n\
 delete name    Delete user's cert\n\
\n\
        * Manage CA/VPN certs *\n\
 createca       Build the CA certs\n\
 deleteca       Delete ALL CA and user/device certs/keys (irreversible!)\n\
 makevpncert    Create an additional VPN cert/key\n\
 makecacert     Create an additional CA cert/key\n\
 listca         List all CA and VPN cert names\n\
 showca         Show CA and associated VPN certs\n\
 showcert       List cert contents\n\
\n\
        * pistrong configuration and Strongswan service management *\n\
 config         Modify or print config settings\n\
 service        Manage the strongSwan service\n\
\n\
        * Miscellaneous *\n\
 install        Starts strongSwan installation with 'InstallPiStrong all'\n\
 version        Print the pistrong version\n\
 help           Print this message\n\
\n\
Command-line switches override config file settings.\n\
\n\
Examples:\n\
\n\
pistrong --help\n          Get help about switches\n\
pistrong createca\n          Create a new CA in the root directory (/etc/swanctl)\n\
pistrong createca --vpnsankey keyname\n          Create a new CA with a different vpnsankey (d:ipsec.vpn.net)\n\
pistrong deleteca\n          Delete the CA, all certs, etc. Be really sure on this one!\n\
pistrong makevpncert --vpnsankey key1,key2 --vpncert mycert\n\
          Make an additional VPN cert/key named mycert. key1 and key2 will be\n\
          the SAN names in the cert\n\
pistrong add name\n          Add user 'name' and create a cert for it\n\
          The full username will be name-dev\n\
pistrong add name --password abc\n          Provide the cert password on the command line\n\
pistrong add name --device DEVICE\n          Name the cert name-DEVICE-servername@cnsuffix\n          (d: name-dev-servername...)\n\
pistrong add name --nopass\n          Password for cert import is null\n\
pistrong add name --random\n          Generate a random cert install password\n          Cert install passwords are saved in /etc/swanctl/pistrong/pistrongdb.json\n\
pistrong add name --mail users-email@somewhere.com\n          Send mail to the user with a link to the certs\n          Cert passwords are sent separately\n\
          --webdir dir --weburl url from the configuration or on command line\n\
pistrong list\n          List all user certs\n\
pistrong list name --all\n          List all certs for 'name'\n\
pistrong list user --full\n          Show specific user plus cert details\n\
pistrong resend name --mail users-email@somewhere.com\n          Resend the cert link and password to the user\n\
\n\
A full user name is name-dev. 'bill-iphone', for instance. If you don't specify\n\
--device, names will be 'name-dev' (e.g., 'bill-dev').\n\
The list command requires a full name-dev, except when used with --all,\n\
which will list all certs for the specified name.\n\
\n\
For example, 'pistrong list bill --all' will list the certs for bill-iphone\n\
and bill-laptop.\n\
\n\
The revoke and resend commands always require a full name-dev.\n\
\n\
You MUST specify --vpnsankey or --novpncert when you first create a CA.\n\
\n\
See the full documentation at https://github.com/gitbls/pistrong\n".format(version)
    print(helpmsg)
    return

def cmd_version(pd, args):
    print("pistrong {}".format(version))
    return
#
# Main program
#
pd = pdat()
parser = argparse.ArgumentParser(
    prog="pistrong",
    description="Manage a strongSwan CA and user certs/keys",
    epilog="Manage a strongSwan CA and user certs/keys. Easily add, revoke,\
    or delete a user's cert. A cert install password can be provided on the command line, \
    randomly generated, or no password. Certs can be sent via a link in email, or copied \
    to the client system via the network, USB stick, etc")

parser.set_defaults(func=cmd_help, cacert=None, debug=False, myfqdn=None, swancertpfx=None, vpncertpfx=None, usedb=True)

ynchoices = ['y', 'yes', 'no', 'n']
parent_parser = argparse.ArgumentParser(add_help=False)
parent_parser.add_argument("--debug", help="Enable debug mode", choices=ynchoices)
parent_parser.add_argument("--cmds", help="Show executed system commands", choices=ynchoices)
parent_parser.add_argument("--root", help="Alternate CA root")
subparsers = parser.add_subparsers(help="Sub-command help")

subparser_config = subparsers.add_parser("config", help="Show/modify stored configuration information", parents=[parent_parser])
subparser_config.add_argument("--list", help="List static configuration parameters", action='store_true')
subparser_config.add_argument("--cacert", help="Specify default CA cert to use [strongSwan]")
subparser_config.add_argument("--calife", help="CA cert lifetime")
subparser_config.add_argument("--cnsuffix", help="Suffix appended to user certs")
subparser_config.add_argument("--crllife", help="Cert revocation list lifetime")
subparser_config.add_argument("--mailfrom", help="'From' string for emails")
subparser_config.add_argument("--myfqdn", help="VPN host FQDN if pistrong needs help")
subparser_config.add_argument("--random", help="Create random cert install passwords", choices=ynchoices)
subparser_config.add_argument("--rootca", help="Name for root CA [strongSwan]")
subparser_config.add_argument("--service", help="strongSwan service name")
subparser_config.add_argument("--smtppassword", help="Password for SMTP mail server authentication")
subparser_config.add_argument("--smtpport", help="Port for smtp mail server")
subparser_config.add_argument("--smtpserver", help="SMTP server IP address")
subparser_config.add_argument("--smtpuser", help="User for SMTP mail server authentication")
subparser_config.add_argument("--smtpusetls", help="Use TLS for SMTP auth", choices=ynchoices)
subparser_config.add_argument("--swancertpfx", help="Default CA name [strongSwan]")
subparser_config.add_argument("--uclife", help="User cert lifetime")
subparser_config.add_argument("--vpnaddr", help="VPN Server DNS name or IP address")
subparser_config.add_argument("--vpncertpfx", help="Default VPN cert name [default]")
subparser_config.add_argument("--vpnsankey", help="Default VPN SAN key") # Sets the default if not specified on createca/makecacert/makevpncert
subparser_config.add_argument("--webdir", help="Web server directory for users p12 and CA certs")
subparser_config.add_argument("--weburl", help="URL prefix for Cert in email")
subparser_config.set_defaults(func=cmd_config)

subparser_createca = subparsers.add_parser("createca", help="Create a Certificate Authority", parents=[parent_parser])
subparser_createca.add_argument("cacert", nargs='?', help="CA cert/key name prefix ['strongSwan']")
subparser_createca.add_argument("--keybits", default="4096", help="Default cert key bits [CA/VPN keys: 4096, User:2048]")
subparser_createca.add_argument("--vpncertpfx", help="VPN cert/key name prefix ['default']")
subparser_createca.add_argument("--vpnsankey", help="VPN SAN key(s) for VPN cert")
subparser_createca.add_argument("--nocamsg", help="Don't print the 'CA created message'", action='store_true')
subparser_createca.add_argument("--novpncert", help="Don't make a default VPN cert", action='store_true')
subparser_createca.set_defaults(func=cmd_createca)

subparser_deleteca = subparsers.add_parser("deleteca", help="Delete the ENTIRE CA and all certs/keys", parents=[parent_parser])
subparser_deleteca.set_defaults(func=cmd_deleteca)

subparser_showcert = subparsers.add_parser("showcert", help="Show cert contents", parents=[parent_parser])
subparser_showcert.add_argument("certname", help="File spec for cert to show")
subparser_showcert.set_defaults(func=cmd_showcert)

subparser_makevpncert = subparsers.add_parser("makevpncert", help="Make a VPN cert", parents=[parent_parser])
subparser_makevpncert.add_argument("vpncertpfx", help="VPN cert/key name prefix ['default']")
subparser_makevpncert.add_argument("--cacert", help="CA cert to use")
subparser_makevpncert.add_argument("--keybits", default="4096", help="VPN cert key bits [4096]")
subparser_makevpncert.add_argument("--vpnsankey", help="VPN SAN key(s)")
subparser_makevpncert.set_defaults(func=cmd_makevpncert)

subparser_makecacert = subparsers.add_parser("makecacert", help="Make an additional CA cert", parents=[parent_parser])
subparser_makecacert.add_argument("cacert", help="Name for the cert")
subparser_makecacert.add_argument("--keybits", default="4096", help="CA cert key bits [4096]")
subparser_makecacert.set_defaults(func=cmd_makecacert)

subparser_showca = subparsers.add_parser("showca", help="Show the CA", parents=[parent_parser])
subparser_showca.add_argument("cacert", nargs='?', help="Name of CA to show [strongSwan]")
subparser_showca.set_defaults(func=cmd_showca)

subparser_listca = subparsers.add_parser("listca", help="List all CAs", parents=[parent_parser])
subparser_listca.set_defaults(func=cmd_listca)

subparser_add = subparsers.add_parser("add", help="Add new user", parents=[parent_parser])
subparser_add.add_argument("username", help="Username to add")
subparser_add.add_argument("--cacert", help="CA cert to use")
subparser_add.add_argument("--cname", help="Connection name")
subparser_add.add_argument("--device", help="Device name for identification")
subparser_add.add_argument("--ios", help="Build an iOS Cert", action='store_true')
subparser_add.add_argument("--keybits", default="2048", help="User cert key bits [2048]")
subparser_add.add_argument("--linux", help="Build a Linux VPN Config Pack for this user", action='store_true')
subparser_add.add_argument("--mail", help="User email address")
subparser_add.add_argument("--nopass", help="Cert install requires no password", action='store_true')
subparser_add.add_argument("--password", help="Cert install password")
subparser_add.add_argument("--random", help="Generate random cert install password", choices=ynchoices)
subparser_add.add_argument("--remoteid", help="Remote ID")
subparser_add.add_argument("--uclife", help="User Cert lifetime")
subparser_add.add_argument("--vpnaddr", help="VPN Server DNS Name or IP address")
subparser_add.add_argument("--webdir", help="Web server directory for users p12 and CA certs")
subparser_add.add_argument("--weburl", help="URL prefix for Cert in email")
subparser_add.add_argument("--windows", help="Build a Windows Cert", action='store_true')
subparser_add.add_argument("--zip", help="Email zip file with Certs instead of links", action='store_true')
subparser_add.set_defaults(func=cmd_add)

subparser_delete = subparsers.add_parser("delete", help="Delete user cert/key", parents=[parent_parser])
subparser_delete.add_argument("username", help="Username to delete")
subparser_delete.add_argument("--device", help="Device name for identification")
subparser_delete.set_defaults(func=cmd_delete)

subparser_revoke = subparsers.add_parser("revoke", help="Revoke a user's cert", parents=[parent_parser])
subparser_revoke.add_argument("username", help="Username to revoke")
subparser_revoke.add_argument("--device", help="Device name for identification")
subparser_revoke.set_defaults(func=cmd_revoke)

subparser_list = subparsers.add_parser("list", help="List user certs", parents=[parent_parser])
subparser_list.add_argument("username", nargs='?', help="List only specified username")
subparser_list.add_argument("--all", help="List all certs for specified username", action='store_true')
subparser_list.add_argument("--full", help="Show cert details as well", action='store_true')
subparser_list.set_defaults(func=cmd_list, device=None)

subparser_resend = subparsers.add_parser("resend", help="Resend the cert email to a user", parents=[parent_parser])
subparser_resend.add_argument("username", help="Username for cert (already created)")
subparser_resend.add_argument("--device", help="Device name for identification")
subparser_resend.add_argument("--mail", help="User email address")
subparser_resend.add_argument("--zip", help="Email zip file with Certs instead of links", action='store_true')
subparser_resend.set_defaults(func=cmd_resend)

service_actions = ['reload', 'start', 'stop', 'restart', 'disable', 'enable', 'status']
subparser_service = subparsers.add_parser("service", help="Control the strongSwan service", parents=[parent_parser])
subparser_service.add_argument("action", help="", choices=service_actions)
subparser_service.set_defaults(func=cmd_service)


client_cmd_actions = {'start':[cmd_client_start], 'connect':[cmd_client_start],\
                      'stop':[cmd_client_stop], 'disconnect':[cmd_client_stop],\
                      'install':[cmd_client_install], 'delete':[cmd_client_delete], 'list':[cmd_client_list],\
                      'status':[cmd_client_status]}
subparser_client = subparsers.add_parser("client", help="Manage the VPN Client", parents=[parent_parser])
subparser_client.add_argument("action", help="", choices=client_cmd_actions)
subparser_client.add_argument("vpnorzip", nargs='?', help="VPN (Start, Delete) or zipfile (Install)")
subparser_client.add_argument("--wait", default="5", help="Wait time for VPN to be established [5]")
subparser_client.set_defaults(func=cmd_client)

subparser_help = subparsers.add_parser("help", help="Print some help", parents=[parent_parser])
subparser_help.set_defaults(func=cmd_help, usedb=False)

subparser_version = subparsers.add_parser("version", help="Print the pistrong version", parents=[parent_parser])
subparser_version.set_defaults(func=cmd_version, usedb=False)
#
# Parse the command and dispatch
#
args = parser.parse_args()

usedb = args.usedb
thefunc = args.func
# Need to test thefunc as well b/c pistrong cmd w/no args has usedb set to true (argparse defaulting convenience)
if usedb and thefunc != cmd_help:
    pd.dx['debug'] = trueorfalse(args.debug) if args.debug else False # This isn't known yet :( pd.db['config']['debug']['value']

    pd.swandir = "." if pd.dx['debug'] else "/etc/swanctl"
    if (args.root != None):
        pd.swandir = args.root
    if pd.swandir != "/etc/swanctl":
        print("% Using {} for CA root directory".format(pd.swandir))
    pd.pswandir = "{}/pistrong".format(pd.swandir)
    pd.certdb = "{}/pistrongdb.json".format(pd.pswandir)
    pd.dbmodified = False
    dbload(pd)
    gethostfqdn(pd, args)
    makefilenames(pd, args)
    if pd.db['config']['validids']['value'] == "": findvalidids(pd)   # Fix old pistrongdb.json 
    if pd.db['config']['vpnaddr']['value'] == "": pd.db['config']['vpnaddr']['value'] = pd.hostfqdn
    pd.dx['debug'] = trueorfalse(args.debug) if args.debug else pd.db['config']['debug']['value']
    pd.dx['cmds'] = trueorfalse(args.cmds) if args.cmds else pd.db['config']['cmds']['value']
    if pd.db['config']['service']['value'] == "":
        perrorexit("? Can't determine strongSwan service name\n% Edit service name in {}".format(pd.certdb))
thefunc(pd, args)
if pd.dbmodified: dbflush(pd)
exit
