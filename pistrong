#!/usr/bin/python3

""" 
Manage strongswan Certificate Authority (CA) and user certs/keys via the command line
"""
import argparse
import datetime
import json
import os
import pexpect
import pprint
import random
import re
import shutil
import smtplib
import socket
import subprocess
import sys
import termios
from email.mime.text import MIMEText

class pdat:
    def __init__(self):
        self.dbmodified = False
        self.cadirlist = {}
        self.db = {}
        self.dx = {"debug":False}
        self.swandir = self.certdb = self.certdbak = self.certdbtmp = ""
        self.dnou = self.dx509 = self.dx509ca = self.dx509crl = self.dprivate = self.dp12 = ""
        self.rootca = self.swancertpfx = self.swancertfn = self.swancert = self.swankey = ""
        self.vpncertpfx = self.vpnhostcert = self.vpnhostkey = self.clientcertfmt = self.clientkeyfmt = ""
        self.clientcert = self.clientkey = self.newp12fn = self.newp12 = self.cn = ""
        self.fnpdir = "{}/{}"
        self.revokecrl = self.revoketmp = self.hostfqdn = self.shorthost = self.vpnip = ""

version = "3.0"
dbversion = "3"

helpmsg = "pistrong {} commands:\n\
\n\
        * Manage user certs *\n\
 add    name    Create a new user/device cert\n\
 resend name    Resend cert info to user\n\
 list   [name]  List users (see examples)\n\
 revoke name    Revoke user's cert\n\
 delete name    Delete user's cert\n\
\n\
        * Manage CA/VPN certs *\n\
 createca       Build the CA certs\n\
 deleteca       Delete ALL CA and user/device certs/keys (irreversible!)\n\
 makevpncert    Create an additional VPN cert/key\n\
 makecacert     Create an additional CA cert/key\n\
 listca         List all CA and VPN cert names\n\
 showca         Show CA and associated VPN certs\n\
 showcert       List cert contents\n\
\n\
        * pistrong configuration and Strongswan service management *\n\
 config         Modify or print config settings\n\
 service        Manage the strongSwan service\n\
\n\
        * Miscellaneous *\n\
 install        Starts strongSwan installation with 'InstallPiStrong all'\n\
 version        Print the pistrong version\n\
 help           Print this message\n\
\n\
Command-line switches override config file settings.\n\
\n\
Examples:\n\
\n\
pistrong --help\n          Get help about switches\n\
pistrong createca\n          Create a new CA in the root directory (/etc/swanctl)\n\
pistrong createca --vpnsankey keyname\n          Create a new CA with a different vpnsankey (d:ipsec.vpn.net)\n\
pistrong deleteca\n          Delete the CA, all certs, etc. Be really sure on this one!\n\
pistrong makevpncert --vpnsankey key1,key2 --vpncert mycert\n\
          Make an additional VPN cert/key named mycert. key1 and key2 will be\n\
          the SAN names in the cert\n\
pistrong add name\n          Add user 'name' and create a cert for it\n\
          The full username will be name-dev\n\
pistrong add name --password abc\n          Provide the cert password on the command line\n\
pistrong add name --device DEVICE\n          Name the cert name-DEVICE-servername@cnsuffix\n          (d: name-dev-servername...)\n\
pistrong add name --nopass\n          Password for cert import is null\n\
pistrong add name --random\n          Generate a random cert install password\n          Cert install passwords are saved in /etc/swanctl/pistrongdb.json\n\
pistrong add name --mail users-email@somewhere.com\n          Send mail to the user with a link to the certs\n          Cert passwords are sent separately\n\
          --webdir dir --weburl url from the configuration or on command line\n\
pistrong list\n          List all user certs\n\
pistrong list name --all\n          List all certs for 'name'\n\
pistrong list user --full\n          Show specific user plus cert details\n\
pistrong resend name --mail users-email@somewhere.com\n          Resend the cert link and password to the user\n\
\n\
A full user name is name-dev. 'bill-iphone', for instance. If you don't specify\n\
--device, names will be 'name-dev' (e.g., 'bill-dev').\n\
The list command requires a full name-dev, except when used with --all,\n\
which will list all certs for the specified name.\n\
\n\
For example, 'pistrong list bill --all' will list the certs for bill-iphone\n\
and bill-laptop.\n\
\n\
The revoke and resend commands always require a full name-dev.\n\
\n\
You MUST specify --vpnsankey when you first create a CA.\n\
\n\
See the full documentation at https://github.com/gitbls/pistrong\n".format(version)

def qdelfile(qfn):
    """
    Silently delete a file. Errors masked.
    """
    try:
        os.remove(qfn)
    except OSError:
        pass

def qrename(src, dst):
    """
    Rename the src file to be dst. Errors masked.
    """
    try:
        os.rename(src, dst)
    except OSError:
        pass

def qcopyfile(src, dst):
    """
    Copy src file to dst
    """
    print("% Copying '{}' to '{}'".format(src, dst))
    shutil.copy(src, dst)

def askyn(question):
    """
    Prompt for an answer with the given question.
    Returns True if yes, False if anything else
    """
    yni = input(question)
    if yni == "y" or yni == "Y" or yni == "yes": return True
    return False

def asktwice(question):
    """
    Prompt for an answer to a question, and if yes, ask "are you sure"
    """
    if askyn("{} [y/N] ".format(question)) and askyn("Are you sure? [y/N] "):
        return True
    return False

def trueorfalse(answer):
    s = answer.lower()   # parser only accepts lower case, just being cautious
    if (s == "y") or (s == "yes") or (s == "on"): return True
    if (s == "n") or (s == "no") or (s == "off"): return False
    perrorexit("? Unrecognized switch value '{}'".format(answer))  #SNH due to parser checking

def isrootordebug(pd, args):
    pd.dx['debug'] = trueorfalse(args.debug) if args.debug else pd.db['config']['debug']['value']
    pd.dx['cmds'] = trueorfalse(args.cmds) if args.cmds else pd.db['config']['cmds']['value']
    if not pd.dx['debug'] and os.geteuid() != 0: perrorexit("? Must be run as root or --debug on")

def which(fname):
    """
    Returns the full path for for the executable if found on PATH
    """
    for path in os.environ["PATH"].split(os.pathsep):
        fullpath = os.path.join(path, fname)
        if os.path.exists(fullpath) and os.access(fullpath, os.X_OK):
            return fullpath
    return None

def dosystem(pd, docmd):
    """
    Execute the string as a separate process, optionally display command
    """
    if pd.dx['cmds']:
        print("[{}]".format(docmd))
    return subprocess.call(docmd, shell=True)

def dosystemx(pd, docmd):
    """
    Same as dosystem but never prints command
    """
    return subprocess.call(docmd, shell=True)

def isrunning(pd):
    """
    Returns 0 if strongswan service is running
    """
    return dosystemx(pd, "systemctl --quiet is-active {}".format(pd.db['config']['service']['value']))

def stopifrunning(pd):
    """
    Stops strongswan if it's running, and returns previous running status
    """
    strunning = isrunning(pd)
    if strunning == 0:
        if not pd.dx['debug']:
            print("% Stopping {}".format(pd.db['config']['service'])['value'])
            dosystemx(pd, "systemctl stop {}".format(pd.db['config']['service']['value']))
        else:
            strunning = 1
    return strunning

def startifwas(pd, running):
    """
if strongswan was running before, as indicated by argument, restart it
    """
    if running == 0:
        if not pd.dx['debug']:
            print("% Starting {}".format(pd.db['config']['service']['value']))
            dosystemx(pd, "systemctl start {}".format(pd.db['config']['service']['value']))

def perrorexit(emsg):
    """
    Print the message and exit the program
    """
    raise SystemExit(emsg)

def makefilenames(pd, args):
    pd.certdbak = "{}/bak-pistrongdb.json".format(pd.swandir)
    pd.certdbtmp = "{}/pistrongdb.tmp".format(pd.swandir)
    pd.dnou = "{}-strongSwan".format(pd.shorthost)
    pd.dx509 = "{}/x509".format(pd.swandir)
    pd.dx509ca = "{}/x509ca".format(pd.swandir)
    pd.dx509crl = "{}/x509crl".format(pd.swandir)
    pd.dprivate = "{}/private".format(pd.swandir)
    pd.dp12 = "{}/p12".format(pd.swandir)
    pd.rootca = "{} {} Root CA".format(pd.db['config']['rootca']['value'], pd.shorthost)
    pd.swancertpfx = pd.db['config']['swancertpfx']['value'] if args.cacert is None else args.cacert
    pd.swancertfn = "{}CACert.pem".format(pd.swancertpfx)
    pd.swancert = "{}/{}".format(pd.dx509ca, pd.swancertfn)
    pd.swankey = "{}/{}CAKey.pem".format(pd.dprivate, pd.swancertpfx)
    pd.revokecrl = "{}/revoked.der".format(pd.dx509crl)
    pd.revoketmp = "{}/tmprevoked.der".format(pd.dx509crl)
    pd.cadirlist = {pd.dx509:0o755, pd.dx509ca:0o755, pd.dx509crl:0o755, pd.dprivate:0o750, pd.dp12:0o750}
    pd.clientcertfmt = "{}/{}-{}Cert.pem"
    pd.fnpdir = "{}/{}"

def makeclientfnames(pd, args, newkey):
    pd.clientcert = pd.clientcertfmt.format(pd.dx509, newkey, pd.shorthost)
    pd.clientkeyfmt = "{}/{}-{}Key.pem"
    pd.clientkey = pd.clientkeyfmt.format(pd.dprivate, newkey, pd.shorthost)
    pd.newp12fn = "{}-{}.p12".format(newkey, pd.shorthost)
    pd.newp12 = pd.fnpdir.format(pd.dp12, pd.newp12fn) 
    pd.cn = "{}-{}@{}".format(newkey, pd.shorthost, pd.db['config']['cnsuffix']['value'])

def makevpnfns(pd, args):
    pd.vpncertpfx = pd.db['config']['vpncertpfx']['value'] if args.vpncertpfx is None else args.vpncertpfx
    pd.vpnhostcert = "{}/{}-{}VPNCert.pem".format(pd.dx509, pd.vpncertpfx, pd.swancertpfx)
    pd.vpnhostkey = "{}/{}-{}VPNKey.pem".format(pd.dprivate, pd.vpncertpfx, pd.swancertpfx)
    pd.dx['vpnsankey'] = args.vpnsankey if args.vpnsankey else pd.db['config']['vpnsankey']['value']

def sendmsg(pd, mfrom, mto, msubj, mtext):
    """
    Send an email message. May still need work on authentication
    """
    mmsg = MIMEText(mtext)
    mmsg['From'] = mfrom
    mmsg['To'] = mto
    mmsg['Subject'] = msubj
    msmtp = smtplib.SMTP(pd.db['config']['smtpserver']['value'], pd.db['config']['smtpport']['value'])
    if pd.db['config']['smtpusetls']['value']:
       msmtp.starttls()
    try:
        msmtp.login(pd.db['config']['smtpuser']['value'], pd.db['config']['smtppassword']['value'])
    except smtplib.SMTPException:  # no login needed if "smart host"
        pass
    msmtp.sendmail(mfrom, mto, mmsg.as_string())
    msmtp.quit()

def genrandpwd():
    """
    Generate a 32-character sequence of random letters and numbers
    """
    chars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
    spwd = ""
    for irand in range(0, 31):
        spwd += random.choice(chars)
    return spwd

def getpwd():
    """
    Get and verify a password from user, with echo off
    """
    pw1 = "no"
    pw2 = "match"
    stdinfd = sys.stdin.fileno()
    oldtcattr = termios.tcgetattr(stdinfd)
    newtcattr = termios.tcgetattr(stdinfd)
    newtcattr[3] = newtcattr[3] & ~termios.ECHO
    termios.tcsetattr(stdinfd, termios.TCSADRAIN, newtcattr)
    try:
        while pw1 != pw2:
            pw1 = input("Enter password: ")
            print("")
            pw2 = input("Verify password: ")
            print("")
            if pw1 != pw2:
                print("% Passwords do not match. Try again.")
    finally:
        termios.tcsetattr(stdinfd, termios.TCSADRAIN, oldtcattr)
    return pw1

def mkpkcs12zpw(pd, pzcmd):
    """
    Make the .p12 file with no password prompts, with a null password
    """
    if pd.dx['cmds']:
        print("[{}]".format(pzcmd))
    child = pexpect.spawn(pzcmd)
    child.expect("Enter Export Password:")
    child.sendline("")
    child.expect("Verifying - Enter Export Password:")
    child.sendline("")
    child.expect(pexpect.EOF)

def reloadcreds(pd):
    """
    If strongswan is running, reload the VPN's credentials
    """
    if isrunning(pd) == 0:
        print("% Reloading strongSwan VPN credentials...")
        dosystem(pd, "swanctl --load-creds")  # reload credentials

def gethostfqdn(pd, args):
    pd.hostfqdn = socket.getfqdn()
    pd.shorthost = pd.hostfqdn.split(".")[0]
    pd.vpnip = socket.gethostbyname(pd.hostfqdn)
    if pd.vpnip.split(".")[0] == "127":
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            pd.vpnip = s.getsockname()[0]
        except:
            pd.vpnip = "127.0.0.1"  # In case it came out as 127.0.1.1
            print("% Couldn't divine host IP address. Using 127.0.0.1. Check /etc/hosts")
        s.close()

    if not "." in pd.hostfqdn:
        if pd.db['config']['myfqdn']['value'] != "":
            pd.hostfqdn = pd.db['config']['myfqdn']['value']
        else:
            if args.myfqdn == None: print("% Unable to obtain a fully-qualified domain name for this host\n  This may impact internet accessibility for the VPN\n  Use 'pistrong config --myfqdn' and/or see the pistrong README")

def dbload(pd):
    """
    Read the cert database and build a dictionary
    """
    if os.path.isfile(pd.certdb):
        with open(pd.certdb,'r') as dbf:
            try:
                pd.db = json.load(dbf)
            except ValueError:
                perrorexit("? Database {} has invalid syntax".format(pd.certdb))
    # If a section isn't there, create it. Will be saved later
    if not (('users' in pd.db) and ('config' in pd.db) and ('certs' in pd.db)): pd.dbmodified = True
    if not 'users' in pd.db:
        pd.db['users'] = {}
    if not 'config' in pd.db:
# rootca, swancertpfx, vpncertpfx
        pd.db['config'] = {"rootca":{"value":"strongSwan","help":"String for root CA name [strongSwan]"},\
                           "swancertpfx":{"value":"strongSwan","help":"CA Cert name prefix [strongSwan]"},
                           "swandir":{"value":"/etc/swanctl", "help":"System directory for strongSwan [/etc/swanctl]"},
                           "vpncertpfx":{"value":"default","help":"VPN Cert name prefix [default]"},\
                           "crllife":{"value":"7","help":"Cert Revocation List lifetime [7 days]"},\
                           "calife":{"value":"3650","help":"CA Lifetime [3650 days]"},\
                           "uclife":{"value":"730","help":"User Cert Lifetime [730 days]"},\
                           "myfqdn":{"value":"","help":"VPN host FQDN (Fully Qualified Domain Name)"},\
                           "version":{"value":"3.0","help":"Database version"},\
                           "vpnsankey":{"value":"ipsec.vpn.net","help":"Default VPN SAN key"},\
                           "cnsuffix":{"value":"ipsec.vpn","help":"Suffix for user cert names"},\
                           "service":{"value":"strongswan.service","help":"strongSwan service name"},\
                           "cmds":{"value":False,"help":"Echo executed commands"},\
                           "debug":{"value":False,"help":"Debug mode"},\
                           "random":{"value":True,"help":"Generate random cert passwords"},\
                           "mailfrom":{"value":"PiStrongVPN<root@mydomain.com>","help":"'From' string for cert email"},\
                           "smtpserver":{"value":"127.0.0.1","help":"SMTP mail server IP address or name"},\
                           "smtpport":{"value":"25","help":"SMTP mail server port"},\
                           "smtpuser":{"value":"","help":"SMTP mail server username if required"},\
                           "smtppassword":{"value":"","help":"SMTP mail server password if required"},\
                           "smtpusetls":{"value":False,"help":"SMTP Mail use TLS auth [NYI]"},\
                           "webdir":{"value":"tmp","help":"Directory in file system corresponding to weburl"},\
                           "weburl":{"value":"http://127.0.0.1","help":"Web URL on which to append cert name"}}
    if not ('version' in pd.db['config']) or (pd.db['config']['version']['value'] < "3"):
            perrorexit("? {} is from a prior version. See documentation".format(pd.certdb))
    pd.db['config']['version']['value'] = dbversion    # Force to current version. Will get written to DB first time a real update is done
    if not 'myfqdn' in pd.db['config']:
        pd.db['config']['myfqdn'] = {"value":"","help":"VPN host Fully Qualified Domain Name"}
    if not 'certs' in pd.db:
        pd.db['certs'] = {}

def keyindb(pd, keyname):
    """
    Return true if key in database, false if not. Separate function for readability
    """
    if keyname in pd.db['users']: return True
    return False

def dbflush(pd):
    """
    Flush the database to disk. Do any time database changes
    """
    qdelfile(pd.certdbtmp)
    with open(pd.certdbtmp, "w") as dbfw:
        json.dump(pd.db, dbfw, indent=4, sort_keys=True)
        dbfw.write("\n") # json.dump doesn't put out a final eol lol
    os.chmod(pd.certdbtmp, 0o600)
    qdelfile(pd.certdbak)
    qrename(pd.certdb, pd.certdbak)
    qrename(pd.certdbtmp, pd.certdb)
    pd.dbmodified = False

def dbupdate(pd, keyname, newstatus, upwd, ca, remoteid):
    """
    Add a new entry or update entry in database. newstatus=V|R (valid | revoked)
    """
    if not keyname in pd.db['users']:
        pd.db['users'][keyname] = {}
    pd.db['users'][keyname]['ca'] = ca
    pd.db['users'][keyname]['state'] = newstatus
    pd.db['users'][keyname]['date'] = datetime.datetime.strftime(datetime.datetime.now(), "%Y-%m-%d:%H:%M:%S")
    pd.db['users'][keyname]['password'] = upwd
    pd.db['users'][keyname]['remoteid'] = remoteid
    dbflush(pd)

def makekeyname(pd, args):
    """
    Create keyname (username-dev) and check validity
    """
    newkey = args.username if args.username != None else ""
    devname = "dev" if args.device is None else args.device
    if newkey != "" and not "-" in newkey:
        newkey = "{}-{}".format(newkey, devname)
    if " " in newkey:
        perrorexit("? Space not allowed in user name")
    return newkey

def getcertkey(certfile, keyname):
    """
    Returns the specified "keyname:" from a cert in readable format
    """
    acert = subprocess.check_output(("pki --print --type x509 --in {}".format(certfile)), shell=True)
    for line in acert.decode('utf8').split("\n"):
        if keyname in line:
            return line.replace(keyname,"").strip()
    return ""

def maxcacertname(pd):
    maxnam = 0
    for fn in pd.db['certs']:
        maxnam = max(maxnam, len(fn))
    return maxnam

def maxvpncertname(pd):
    """
    Find the longest VPN cert name
    """
    maxnam = 0
    for fn in os.listdir(pd.dx509):
        if fn.endswith("VPNCert.pem"):
            maxnam = max(maxnam, len(os.fsdecode(fn))-len("VPNCert.pem"))
    return maxnam

def maxremoteid(pd):
    """
    Find the longest remoteid for listing users
    """
    maxr = 0
    for ukey in pd.db['users']:
        maxr = max(maxr, len(pd.db['users'][ukey]['remoteid']))
    return maxr
    
def listentry(pd, listkey, maxkey, maxcertlen, maxrid):
    """
    Print the information for a key. If --full, print the cert as well
    """
    listcert = pd.clientcertfmt.format(pd.dx509, listkey, pd.shorthost)
    print("{sts}       {key:<{wid}} {date} {caname:<{cawid}} {remid:<{rmax}} {password}".format(sts=pd.db['users'][listkey]['state'],\
                                                              key=listkey, wid=maxkey,\
                                                              date=pd.db['users'][listkey]['date'],\
                                                              caname=pd.db['users'][listkey]['ca'], cawid=maxcertlen,\
                                                              remid=pd.db['users'][listkey]['remoteid'],  rmax=maxrid,\
                                                              password=pd.db['users'][listkey]['password']))
    if args.full:
        if os.path.isfile(listcert):
            acert = subprocess.check_output(("pki --print --type x509 --in {}".format(listcert)), shell=True)
            for line in acert.decode('utf8').split("\n"):
                if line != "":
                    print(line)
        else:
            print("% Cert '{}' for user '{}' not found".format(listcert, listkey))
        print("")

def listentries(pd, estatus, keyname, maxkey, maxcertlen, maxrid):
    """
    List a set of selected entries
    """
    for listkey in sorted(pd.db['users']):
        if estatus == pd.db['users'][listkey]['state']:
            if keyname == "":
                listentry(pd, listkey, maxkey, maxcertlen, maxrid)
            else:
                if listkey.split("-")[0] == keyname:
                    listentry(pd, listkey, maxkey, maxcertlen, maxrid)

def mailcert(pd, args, newkey):
    if pd.db['users'][newkey]['password'] == "":
        pwmsg = "Your certificate does not have a password"
    else:
        pwmsg = "Use this password to import the certificate onto your device: {}\n".format(pd.db['users'][newkey]['password'])
    webfn = pd.fnpdir.format(pd.dx['webdir'], pd.newp12fn)
    qcopyfile(pd.newp12, webfn)
    os.chmod(webfn, 0o644)
    webfn = pd.fnpdir.format(pd.dx['webdir'], pd.swancertfn)
    qcopyfile(pd.swancert, webfn)
    os.chmod(webfn, 0o644)
    certurl = pd.fnpdir.format(pd.dx['weburl'], pd.newp12fn)
    cacerturl = pd.fnpdir.format(pd.dx['weburl'], pd.swancertfn)
    msg = "\nRoot CA cert (if needed): {}\nYour device certificate:  {}\n\n".format(cacerturl, certurl)
    msg += "iOS devices: Browse the links to install both certificates (Install CA Cert first).\n"
    msg += "  Then create a new IKEV2 VPN connection using the iOS profile {}\n  and this information:\n".format(pd.cn)
    msg += "          Server:    {}\n          Remote ID: {}\n          Local ID:  {}\n".format(pd.hostfqdn, pd.db['users'][newkey]['remoteid'], pd.cn)
    msg += "  And select the newly-installed device certificate.\n"
    msg += "\nOther devices: See the CertInstall.md guide at https://github.com/gitbls/pistrong\nfor details on importing the certificate onto your device and creating the VPN configuration\n"
    sendmsg(pd, pd.dx['mailfrom'], args.mail, "VPN Cert {}".format(pd.cn), msg)
    sendmsg(pd, pd.dx['mailfrom'], args.mail, "VPN Cert password {}".format(pd.cn), pwmsg)
    print("% Mail sent to {}".format(args.mail))

def makevpncert(pd, args):
    """
    Make a VPN cert
    mvpncert = full path of VPN cert
    mvpnkey = full path of VPN key
    """
    print("\n>> Create VPN Host Key ({})".format(pd.vpnhostkey))
    dosystem(pd, "pki --gen --type rsa --size {} --outform pem > {}".format(args.keybits, pd.vpnhostkey))
    os.chmod(pd.vpnhostkey, 0o600)
    print("\n>> Create VPN Host Cert ({})".format(pd.vpnhostcert))
    print (">> with VPN SAN key(s) {}\n".format(pd.dx['vpnsankey']))
    sankey = pd.dx['vpnsankey']
    sanstring = ""
    for iakey in sankey.split(","):
            sanstring += " --san {}".format(iakey.strip())
    cacmd = "pki --issue --in {} --type rsa --lifetime {} --cacert {} --cakey {} --dn \"C=US, O={}, CN={}\"{} --flag serverAuth --flag ikeIntermediate --outform pem > {}".format(pd.vpnhostkey, pd.db['config']['calife']['value'], pd.swancert, pd.swankey, pd.dnou, pd.hostfqdn, sanstring, pd.vpnhostcert)
    dosystem(pd, cacmd)
    dosystem(pd, "pki --print --in {}".format(pd.vpnhostcert))
    print("")

def makecacert(pd, args):
    """
    """
    print("\n>> Creating CA Key ({})".format(pd.swankey))
    dosystem(pd, "pki --gen --type rsa --size {} --outform pem > {}".format(args.keybits, pd.swankey))
    os.chmod(pd.swankey, 0o600)
    print("\n>> Create self-signed CA Cert ({})\n".format(pd.swancert))
    dosystem(pd, "pki --self --ca --lifetime {} --in {} --type rsa\
    --dn \"C=US, O={}, CN={}\" --outform pem > {}".format(pd.db['config']['calife']['value'], pd.swankey, pd.dnou, pd.rootca, pd.swancert))
    dosystem(pd, "pki --print --in {}".format(pd.swancert))
    pd.db['certs'][pd.swancertpfx.replace(".pem","")] = getcertkey(pd.swancert, "subjkey:")
    pd.dbmodified = True

def makeca(pd, args):
    """
    Make the Certificate Authority (CA)
    """
    print("\n>> Creating strongSwan CA for host {} in directory {}".format(pd.hostfqdn, pd.swandir))
    makecacert(pd, args)
    makevpncert(pd, args)
    pd.dbmodified = True

def listconfig(pd, args):
    maxval = 0
    for i in pd.db['config']:
        ilen = len(pd.db['config'][i]['value']) if type(pd.db['config'][i]['value']) is str else 5
        maxval = max(maxval, ilen)
    print("{ck:<15} {val:<{vwid}} {help}".format(ck="Config Key", val="Value", help="Description", vwid=maxval))
    for i in sorted(pd.db['config']):
        print("{key:<15} {val:<{vwid}} {help}".format(key=i, val=pd.db['config'][i]['value'], help=pd.db['config'][i]['help'], vwid=maxval))
    
def cmd_config(pd, args):
    if args.debug:        pd.db['config']['debug']['value'] = trueorfalse(args.debug)
    if args.cmds:         pd.db['config']['cmds']['value'] = trueorfalse(args.cmds)
    if args.cacert:       pd.db['config']['cacert']['value'] = args.cacert
    if args.calife:       pd.db['config']['calife']['value'] = args.calife
    if args.cnsuffix:     pd.db['config']['cnsuffix']['value'] = args.cnsuffix
    if args.crllife:      pd.db['config']['crllife']['value'] = args.crllife
    if args.mailfrom:     pd.db['config']['mailfrom']['value'] = args.mailfrom
    if args.myfqdn:       pd.db['config']['myfqdn']['value'] = args.myfqdn
    if args.random:       pd.db['config']['random']['value'] = trueorfalse(args.random)
    if args.rootca:       pd.db['config']['rootca']['value'] = args.rootca
    if args.service:      pd.db['config']['service']['value'] = args.service
    if args.smtppassword != None:  pd.db['config']['smtppassword']['value'] = args.smtppassword
    if args.smtpport:     pd.db['config']['smtpport']['value'] = args.smtpport
    if args.smtpserver:   pd.db['config']['smtpserver']['value'] = args.smtpserver
    if args.smtpusetls:   pd.db['config']['smtpusetls']['value'] = args.smtpusetls
    if args.swancertpfx:  pd.db['config']['swancertpfx']['value'] = args.swancertpfx
    if args.uclife:       pd.db['config']['uclife']['value'] = args.uclife
    if args.vpncertpfx:   pd.db['config']['vpncertpfx']['value'] = args.vpncertpfx
    if args.vpnsankey:    pd.db['config']['vpnsankey']['value'] = args.vpnsankey
    if args.webdir:       pd.db['config']['webdir']['value'] = args.webdir
    if args.weburl:       pd.db['config']['weburl']['value'] = args.weburl
    if args.debug or args.cmds or args.cacert or args.calife or args.cnsuffix or\
       args.crllife or args.mailfrom or args.myfqdn or args.random or args.service or (args.smtppassword != None) or\
       args.smtpport or args.smtpserver or args.smtpusetls or args.uclife or args.vpnsankey or\
       args.webdir or args.weburl: pd.dbmodified = True
    if args.list or not pd.dbmodified: listconfig(pd, args)
    return

def cmd_add(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    if newkey == "":
        perrorexit("? No user name specified")
    makeclientfnames(pd, args, newkey)
    pd.dx['random'] = trueorfalse(args.random) if args.random else pd.db['config']['random']['value']
    pd.dx['uclife'] = args.uclife if args.uclife else pd.db['config']['uclife']['value']
    if keyindb(pd, newkey):
        perrorexit("? Key '{}' already in use".format(newkey))
    ipwd = "" if args.password is None else args.password
    if not args.nopass:
        if pd.dx['random']:
            ipwd = genrandpwd()
        if ipwd == "":
            ipwd = getpwd()
    cmd = "pki --gen --type rsa --size {} --outform pem > {}".format(args.keybits, pd.clientkey)
    dosystem(pd, cmd)
    os.chmod(pd.clientkey, 0o600)
    cmd = "pki --issue --in {} --type rsa --lifetime {} --cacert {} --cakey {}".format(pd.clientkey, pd.dx['uclife'], pd.swancert, pd.swankey)
    cmd += " --dn \"C=US, O={}, CN={}\" --san {} --outform pem > {}".format(pd.dnou, pd.cn, pd.cn, pd.clientcert)
    dosystem(pd, cmd)
    cmd = "openssl pkcs12 -export -inkey {}".format(pd.clientkey)
    cmd += " -in {} -name \"{}-{} VPN Certificate\"".format(pd.clientcert, newkey, pd.shorthost)
    cmd += " -certfile {} -caname \"{}\"  -out {}".format(pd.swancert, pd.rootca, pd.newp12)
    if ipwd != "":
        cmd += " -passout pass:{}".format(ipwd)
        dosystem(pd, cmd)
    else:
        mkpkcs12zpw(pd, cmd)
    newremoteid = pd.db['config']['vpnsankey']['value'].split(',')[0] if args.remoteid is None else args.remoteid
    dbupdate(pd, newkey, "V", ipwd, pd.swancertpfx, newremoteid)
    if args.mail != None:
        pd.dx['mailfrom'] = pd.db['config']['mailfrom']['value']
        pd.dx['webdir'] = args.webdir if args.webdir != None else pd.db['config']['webdir']['value']
        pd.dx['weburl'] = args.weburl if args.weburl != None else pd.db['config']['weburl']['value']
        mailcert(pd, args, newkey)
    print("% Added {} with Remote ID '{}' using CA Cert {}".format(newkey, newremoteid, pd.swancertpfx))
    return

def cmd_delete(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    makeclientfnames(pd, args, newkey)
    if keyindb(pd, newkey):
        del pd.db['users'][newkey]
        dbflush(pd)
        print("% User cert {} deleted".format(newkey))
        qdelfile(pd.clientcert)
        qdelfile(pd.clientkey)
        qdelfile(pd.newp12)
    else:
        print("% User '{}' not found".format(newkey))
    return

def cmd_revoke(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    makeclientfnames(pd, args, newkey)
    if not keyindb(pd, newkey):
        perrorexit("? User cert '{}' not found".format(newkey))
    if not os.path.isfile(pd.clientcert):
        perrorexit("? Cert '{}' for user '{}' not found".format(pd.clientcert, newkey))
    lastcrl = "--lastcrl {}".format(pd.revokecrl) if os.path.isfile(pd.revokecrl) else ""
    cmd = "pki --signcrl --cacert {} --cakey {}".format(pd.swancert, pd.swankey)
    cmd += " --reason superseded --lifetime {} --cert {} {} > {}".format(pd.db['config']['crllife']['value'], pd.clientcert, pd.lastcrl, pd.revoketmp)
    dosystem(pd, cmd)
    qdelfile(pd.revokecrl)
    qrename(pd.revoketmp, pd.revokecrl)
    dbupdate(pd, newkey, "R", "", "")
    print("% User '{}' revoked".format(newkey))
    print("% Use 'pistrong delete {}' to delete user's certs/keys when ready".format(newkey))
    return

def cmd_resend(pd, args):
    isrootordebug(pd, args)
    newkey = makekeyname(pd, args)
    makeclientfnames(pd, args, newkey)
    if keyindb(pd, newkey):
        pd.dx['mailfrom'] = pd.db['config']['mailfrom']['value']
        pd.dx['webdir'] =   pd.db['config']['webdir']['value']
        pd.dx['weburl'] =   pd.db['config']['weburl']['value']
        mailcert(pd, args, newkey)
    else:
        perrorexit("? User '{}' not found".format(newkey))
    return

def cmd_list(pd, args):
    isrootordebug(pd, args)
    maxnam = 0
    maxcert = maxcacertname(pd)
    maxrid = max (maxremoteid(pd), len("Remote ID"))
    newkey = "" if args.username == None else makekeyname(pd, args)
    if newkey == "":
        for ukey in pd.db['users']:
            maxnam = max(maxnam, max(len(ukey), len("Key name ")))
        if not args.full:
            print("Status  {key:<{wid}} {date:<20}{cacert:<{camax}} {remid:<{rmax}} Password".format(wid=maxnam, key="Key name", cacert="CA", camax=maxcert, date="Date", remid="Remote ID", rmax=maxrid))
        listentries(pd, "V", "", maxnam, maxcert, maxrid)
        listentries(pd, "R", "", maxnam, maxcert, maxrid)
    else:
        if args.all:
            for ukey in pd.db['users']:
                if ukey.split("-")[0] == args.username:
                    maxnam = max(maxnam, len(ukey))
                # List valid entries, then revoked entries
            listentries(pd, "V", args.username, maxnam, maxcert, maxrid)
            listentries(pd, "R", args.username, maxnam, maxcert, maxrid)
        else:
            if keyindb(pd, newkey):
                listentry(pd, newkey, len(newkey), maxcert, maxrid)
            else:
                print("? User '{}' not found".format(newkey))

    return

def cmd_createca(pd, args):
    """
    makeca command execution
    """
    isrootordebug(pd, args)
    for cadir in pd.cadirlist:
        if not os.path.isdir(cadir): os.mkdir(cadir, pd.cadirlist[cadir])
    if os.path.isfile(pd.swancert):
        perrorexit("? There is already a CA in this directory\n% Use 'pistrong deleteca' first")
    sts = stopifrunning(pd)
    makevpnfns(pd, args)
    if pd.dx['vpnsankey'] != "ipsec.vpn.net":
        makeca(pd, args)
        print("% CA created in {}".format(pd.swandir))
        print("% You may need to update {}/swanctl.conf to appropriately set the Cert and/or VPN SAN key".format(pd.swandir))
    else:
        perrorexit("? You must specify --vpnsankey with other than the default 'ipsec.vpn.net'")
    print ("% Don't forget to 'pistrong start' the service")
    return

def cmd_deleteca(pd, args):
    """
    Deletes the CA. Everything.
    """
    isrootordebug(pd, args)
    print("% WARNING: This will delete all CA and user certs and all keys in {}".format(pd.swandir))
    if asktwice("Do you want to continue?"):
        stopifrunning(pd)
        for cadir in pd.cadirlist:
            shutil.rmtree(cadir, ignore_errors=True)
            if not os.path.isdir(cadir): os.mkdir(cadir, pd.cadirlist[cadir])
        pd.db['users'] = {}    # Delete all the users and flush certdb
        pd.db['certs'] = {}
        dbflush(pd)
        print("% CA Deleted. swanctl.conf and pistrongdb.json configuration settings NOT changed")
    else:
        print("% CA NOT deleted")
    return

def cmd_makevpncert(pd, args):
    """
    Make a new VPN cert command. pistrong makevpncert --vpncert MyCert makes MyCertVPNCert/MyCertVPNKey
    """
    isrootordebug(pd, args)
    if not os.path.isfile(pd.swancert):
        perrorexit("? CA Cert {} missing".format(pd.swancert))
    makevpnfns(pd, args)
    if os.path.isfile(pd.vpnhostcert) or os.path.isfile(pd.vpnhostkey):
        perrorexit("? VPN Host Cert {} and/or VPN Host Key {} already exist".format(pd.vpnhostcert, pd.vpnhostkey))
    makevpncert(pd, args)
    return

def cmd_makecacert(pd, args):
    """
    Make an additional CA Cert/Key
    """
    isrootordebug(pd, args)
    if os.path.isfile(pd.swancert) or os.path.isfile(pd.swankey):
        perrorexit("? CA Cert {} or CA Key {} already exist".format(pd.swancert, pd.swankey))
    makecacert(pd, args)
    return

def cmd_showcert(pd, args):
    isrootordebug(pd, args)
    if os.path.isfile(args.certname):
        print("[Certificate {}]".format(args.certname))
        dosystem(pd, "pki --print --in {}".format(args.certname))
    else:
        perrorexit("? Certificate {} not found".format(args.certname))
    return

def cmd_showca(pd, args):
    isrootordebug(pd, args)
    print("[CA Certificate {}]".format(pd.swancert))
    dosystem(pd, "pki --print --in {}".format(pd.swancert))
    for fn in os.listdir(pd.dx509):
        filename = os.fsdecode(fn)
        if filename.endswith("{}VPNCert.pem".format(pd.swancertpfx)):
            print("\n[VPN Host Certificate {}]".format("{}/{}".format(pd.dx509, filename)))
            dosystem(pd, "pki --print --in {}".format(format("{}/{}".format(pd.dx509, filename))))
    if os.path.isfile(pd.revokecrl):
        print("\n[Revoked CRL {}]".format(pd.revokecrl))
        dosystem(pd, "pki --print --in {} --type crl".format(pd.revokecrl))

    return

def cmd_listca(pd, args):
    isrootordebug(pd, args)
    maxnam = maxcacertname(pd)
    maxvpncert = maxvpncertname(pd)
    if maxnam <= 0: return    # no CA files found
    print("\n{h1:<{mx1}}      {h2}".format(h1="Cert Name", mx1=maxnam, h2="CA Cert Subject Key"))
    for cacertfn in sorted(pd.db['certs']):
        print(" CA {cfn:<{mx1}}  {skey}".format(mx1=maxnam, cfn=cacertfn, skey=pd.db['certs'][cacertfn]))
        caname = cacertfn.replace("CACert", "")
        for fn2 in os.listdir(pd.dx509):
            filename = os.fsdecode(fn2)
            if filename.endswith("{}VPNCert.pem".format(caname)):
                print("  VPN {cfn:<{mx1}} SAN: {skey}".format(mx1=maxvpncert, cfn=filename.replace("VPNCert.pem",""), skey=getcertkey("{}/{}".format(pd.dx509,fn2), "altNames:")))
    return

def cmd_service(pd, args):
    isrootordebug(pd, args)
    if os.geteuid() == 0:
        if args.action == "reload":
            reloadcreds(pd)
        else:
            dosystemx(pd, "systemctl {} {}".format(args.action, pd.db['config']['service']['value']))
    return

def cmd_install(pd, args):
    isrootordebug(pd, args)
    if os.geteuid() != 0:
        perrorexit("? You must be root to install")
    if os.path.isfile(pd.swancert):
        if not asktwice("% strongSwan is already installed.\n  This will reinstall strongSwan and reset your configuration.\n  Do you really want to continue?"): exit()
    cmd = which("InstallPiStrong")
    if cmd != None:
        dosystem(pd, "{} all".format(cmd))
    else:
        perrorexit("? Could not find InstallPiStrong. Download it manually from ????? and then 'sudo InstallPiStrong all'")
    return

def cmd_help(pd, args):
    print(helpmsg)
    return

def cmd_version(pd, args):
    print("pistrong {}".format(version))
    return
#
# Main program
#
pd = pdat()
parser = argparse.ArgumentParser(
    prog="pistrong",
    description="Manage a strongSwan CA and user certs/keys",
    epilog="Manage a strongSwan CA and user certs/keys. Easily add, revoke,\
    or delete a user's cert. A cert install password can be provided on the command line, \
    randomly generated, or no password. Sending mail with a link to the cert provides an easy way \
    for the user to install the cert on a device, but requires that you can send mail via local SMTP service or smarthost\
    and have a web server.")

ynchoices = ['y', 'yes', 'no', 'n']
parent_parser = argparse.ArgumentParser(add_help=False)
parent_parser.add_argument("--debug", help="Enable debug mode", choices=ynchoices)
parent_parser.add_argument("--cmds", help="Show executed system commands", choices=ynchoices)
parent_parser.add_argument("--root", help="Alternate CA root")

subparsers = parser.add_subparsers(help="Sub-command help")

subparser_config = subparsers.add_parser("config", help="Show/modify stored configuration information", parents=[parent_parser])
subparser_config.add_argument("--list", help="List static configuration parameters", action='store_true')
subparser_config.add_argument("--cacert", help="Specify default CA cert to use [strongSwan]")
subparser_config.add_argument("--calife", help="CA cert lifetime")
subparser_config.add_argument("--cnsuffix", help="Suffix appended to user certs")
subparser_config.add_argument("--crllife", help="Cert revocation list lifetime")
subparser_config.add_argument("--mailfrom", help="'From' string for emails")
subparser_config.add_argument("--myfqdn", help="VPN host FQDN if pistrong needs help")
subparser_config.add_argument("--random", help="Create random cert install passwords", choices=ynchoices)
subparser_config.add_argument("--rootca", help="Name for root CA [strongSwan]")
subparser_config.add_argument("--service", help="strongSwan service name")
subparser_config.add_argument("--smtppassword", help="Password for smtp mail server")
subparser_config.add_argument("--smtpport", help="Port for smtp mail server")
subparser_config.add_argument("--smtpserver", help="SMTP server IP address")
subparser_config.add_argument("--smtpusetls", help="Use TLS for SMTP auth", action='store_true')
subparser_config.add_argument("--swancertpfx", help="Default CA name [strongSwan]")
subparser_config.add_argument("--uclife", help="User cert lifetime")
subparser_config.add_argument("--vpncertpfx", help="Default VPN cert name [default]")
subparser_config.add_argument("--vpnsankey", help="Default VPN SAN key") # Sets the default if not specified on createca/makecacert/makevpncert
subparser_config.add_argument("--webdir", help="Web server directory for users p12 and CA certs")
subparser_config.add_argument("--weburl", help="URL prefix for Cert in email")
subparser_config.set_defaults(func=cmd_config, swancertpfx=None, vpncertpfx=None, usedb=True)

subparser_createca = subparsers.add_parser("createca", help="Create a Certificate Authority", parents=[parent_parser])
subparser_createca.add_argument("cacert", nargs='?', help="CA cert/key name prefix ['strongSwan']")
subparser_createca.add_argument("--keybits", default="4096", help="Default cert key bits [CA/VPN keys: 4096, User:2048]")
subparser_createca.add_argument("--vpncertpfx", help="VPN cert/key name prefix ['default']")
subparser_createca.add_argument("--vpnsankey", help="VPN SAN key(s) for VPN cert")
subparser_createca.set_defaults(func=cmd_createca, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_deleteca = subparsers.add_parser("deleteca", help="Delete the ENTIRE CA and all certs/keys", parents=[parent_parser])
subparser_deleteca.set_defaults(func=cmd_deleteca, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_showcert = subparsers.add_parser("showcert", help="Show cert contents", parents=[parent_parser])
subparser_showcert.add_argument("certname", help="File spec for cert to show")
subparser_showcert.set_defaults(func=cmd_showcert, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_makevpncert = subparsers.add_parser("makevpncert", help="Make a VPN cert", parents=[parent_parser])
subparser_makevpncert.add_argument("vpncertpfx", help="VPN cert/key name prefix ['default']")
subparser_makevpncert.add_argument("--cacert", help="CA cert to use")
subparser_makevpncert.add_argument("--keybits", default="4096", help="VPN cert key bits [4096]")
subparser_makevpncert.add_argument("--vpnsankey", help="VPN SAN key(s)")
subparser_makevpncert.set_defaults(func=cmd_makevpncert, swancertpfx=None, myfqdn=None, usedb=True)

subparser_makecacert = subparsers.add_parser("makecacert", help="Make an additional CA cert", parents=[parent_parser])
subparser_makecacert.add_argument("cacert", help="Name for the cert")
subparser_makecacert.add_argument("--keybits", default="4096", help="CA cert key bits [4096]")
subparser_makecacert.set_defaults(func=cmd_makecacert, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_showca = subparsers.add_parser("showca", help="Show the CA", parents=[parent_parser])
subparser_showca.add_argument("cacert", nargs='?', help="Name of CA to show [strongSwan]")
subparser_showca.set_defaults(func=cmd_showca, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_listca = subparsers.add_parser("listca", help="List all CAs", parents=[parent_parser])
subparser_listca.set_defaults(func=cmd_listca, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_add = subparsers.add_parser("add", help="Add new user", parents=[parent_parser])
subparser_add.add_argument("username", help="Username to add")
subparser_add.add_argument("--cacert", help="CA cert to use")
subparser_add.add_argument("--device", help="Device name for identification")
subparser_add.add_argument("--keybits", default="2048", help="User cert key bits [2048]")
subparser_add.add_argument("--mail", help="User email address")
subparser_add.add_argument("--nopass", help="Cert install requires no password", action='store_true')
subparser_add.add_argument("--password", help="Cert install password")
subparser_add.add_argument("--random", help="Generate random cert install password", choices=ynchoices)
subparser_add.add_argument("--remoteid", help="Remote ID")
subparser_add.add_argument("--uclife", help="User Cert lifetime")
subparser_add.add_argument("--webdir", help="Web server directory for users p12 and CA certs")
subparser_add.add_argument("--weburl", help="URL prefix for Cert in email")
subparser_add.set_defaults(func=cmd_add, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_delete = subparsers.add_parser("delete", help="Delete user cert/key", parents=[parent_parser])
subparser_delete.add_argument("username", help="Username to delete")
subparser_delete.add_argument("--device", help="Device name for identification")
subparser_delete.set_defaults(func=cmd_delete, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_revoke = subparsers.add_parser("revoke", help="Revoke a user's cert", parents=[parent_parser])
subparser_revoke.add_argument("username", help="Username to revoke")
subparser_revoke.add_argument("--device", help="Device name for identification")
subparser_revoke.set_defaults(func=cmd_revoke, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_list = subparsers.add_parser("list", help="List user certs", parents=[parent_parser])
subparser_list.add_argument("username", nargs='?', help="List only specified username")
subparser_list.add_argument("--all", help="List all certs for specified username", action='store_true')
subparser_list.add_argument("--full", help="Show cert details as well", action='store_true')
subparser_list.set_defaults(func=cmd_list, cacert=None, swancertpfx=None, vpncertpfx=None, device=None, myfqdn=None, usedb=True)

subparser_resend = subparsers.add_parser("resend", help="Resend the cert email to a user", parents=[parent_parser])
subparser_resend.add_argument("username", help="Username for cert (already created)")
subparser_resend.add_argument("--device", help="Device name for identification")
subparser_resend.add_argument("--mail", help="User email address")
subparser_resend.set_defaults(func=cmd_resend, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

service_actions = ['reload', 'start', 'stop', 'restart', 'disable', 'enable', 'status']
subparser_service = subparsers.add_parser("service", help="Control the strongSwan service", parents=[parent_parser])
subparser_service.add_argument("action", help="", choices=service_actions)
subparser_service.set_defaults(func=cmd_service, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=True)

subparser_install = subparsers.add_parser("install", help="Install strongSwan", parents=[parent_parser])
# myfqdn isn't used for this command, but defining it simplifies gethostfqdn
subparser_install.set_defaults(func=cmd_install, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn="hack.domain.com", usedb=True)

subparser_help = subparsers.add_parser("help", help="Print some help", parents=[parent_parser])
subparser_help.set_defaults(func=cmd_help, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=False)

subparser_version = subparsers.add_parser("version", help="Print the pistrong version", parents=[parent_parser])
subparser_version.set_defaults(func=cmd_version, cacert=None, swancertpfx=None, vpncertpfx=None, myfqdn=None, usedb=False)
#
# Parse the command and dispatch
#
args = parser.parse_args()

if args.usedb:
    pd.dx['debug'] = trueorfalse(args.debug) if args.debug else False # This isn't known yet :( pd.db['config']['debug']['value']

    pd.swandir = "." if pd.dx['debug'] else "/etc/swanctl"
    if (args.root != None):
        pd.swandir = args.root
    if pd.swandir != "/etc/swanctl": print("% Using {} for CA root directory".format(pd.swandir))
    pd.certdb = "{}/pistrongdb.json".format(pd.swandir)
    pd.dbmodified = False
    dbload(pd)
    gethostfqdn(pd, args)
    makefilenames(pd, args)
    pd.dx['debug'] = trueorfalse(args.debug) if args.debug else pd.db['config']['debug']['value']
    pd.dx['cmds'] = trueorfalse(args.cmds) if args.cmds else pd.db['config']['cmds']['value']
    if pd.db['config']['service']['value'] == "":
        perrorexit("? Can't determine strongSwan service name\n% Edit service name in {}".format(pd.certdb))

args.func(pd, args)
if pd.dbmodified: dbflush(pd)
exit
