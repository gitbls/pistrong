#!/bin/bash
# Version V2.0
version="V2.0"
#
# Run this script via sudo After strongSwan is installed
# If you intend to send mail to cert recipients, you'll need an email server and web server
# These don't need to be installed before running this script, but doing so may simplify redoes based on incorrect assumptions
#
function errexit() {
    echo -e "$1"
    exit 1
}

function askyn() {
    local ans
    echo -n "$1" '[y/N]? ' ; read $2 ans
    [ "$dbl" != "" ] && echo ""
    case "$ans" in
        y*|Y*) return 0 ;;
        *) return 1 ;;
    esac
}

function askdefault () {
    # $1=prompt, $2=return variable $3=default-for-prompt-plus-default $4=default-if-provided
    local pmpt=$1 dfl="$3" ddfl="$4" tmp=""
    echo -n "$pmpt [$dfl]: " ; read tmp
    [ "$dbl" != "" ] && echo ""
    if [ "$tmp" == "" ]
    then
	[ "$ddfl" != "" ] && tmp="$ddfl" || tmp="$dfl"
    fi
    eval "${2}=\"${tmp}\""     # Defines a variable with the return value
}

function getnicip() {
    #
    # returns the IP address of the interface, or "" if there isn't one
    #
    local ipaddr="" dev=$1
    ipaddr="$(ip -o -f inet address show dev "$dev" 2>/dev/null | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\/[0-9]{1,2}')"
    echo ${ipaddr%%/*}
    return
}

function isipaddr() {
    #
    # Returns true if $1 is an IP address
    #
    [[ "$1" =~ ^([0-9]{1,3}[\.]){3}[0-9]{1,3} ]] && return 0 || return 1
    return
}

function issubnet() {
    #
    # Returns true if $1 is a subnet
    #
    [[ "$1" =~ ^([0-9]{1,3}[\.]){3}0\/[0-9]{1,2}$ ]] && return 0 || return 1
    return
}

function isnic() {
    #
    # Returns true if $1 is a network adapter (with an IP address)
    #
    [ "$(getnicip $1)" != "" ] && return 0 || return 1
}

function isdomain() {
    local domain="$1"
    [[ "$1" =~ ^([a-zA-Z0-9](([a-zA-Z0-9-]){0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$ ]] && return 0 || return 1
}

function emitFirewall() {
    if [ -f $catables ]
    then
	[ -f $catables.bak ] && rm -f $catables.bak
	mv $catables $catables.bak
	echo "% Saved existing $catables as $catables.bak"
    fi
    cat > $catables <<EOF
#
#  $catables $(date +"%Y-%m-%d %H:%M:%S")
#
#  These are the required iptables rules to enable proper VPN routing
#  You must either 'sudo systemctl enable --now pistrong-iptables-load'
#   or incorporate these rules into your existing iptables configuration file
#
#  These rules are configured for:
#    Internet connection: $vpndev
#    LAN connection:      $landev
#
*nat
:POSTROUTING ACCEPT [0:0]
-A POSTROUTING -s $vpnsubnet -o $vpndev -m policy --dir out --pol ipsec -j ACCEPT
-A POSTROUTING -s $vpnsubnet -o $vpndev -j MASQUERADE
EOF
    [ "$vpndev" != "$landev" ] && echo "-A POSTROUTING -o $vpndev -j MASQUERADE" >> $catables
    echo "COMMIT" >> $catables
    if [ "$vpndev" != "$landev" ]
    then
	# Add iptables entries to route between VPNeth and LANeth
	cat >> $catables <<EOF
*filter
-A FORWARD -i $vpndev -o $landev -m state --state RELATED,ESTABLISHED -j ACCEPT
-A FORWARD -i $landev -o $vpndev -j ACCEPT
COMMIT
EOF
    fi
    [ -f /etc/systemd/system/pistrong-iptables-load.service ] && return
    cat > /etc/systemd/system/pistrong-iptables-load.service <<EOF
[Unit]
Description=Load iptables for strongSwan
Requires=network-online.target

[Service]
ExecStart=/sbin/iptables-restore $catables
User=root
StandardInput=null
StandardOutput=null
StandardError=null
Restart=on-failure

[Install]
WantedBy=multi-user.target

EOF
    chmod 644 /etc/systemd/system/pistrong-iptables-load.service
    echo "** I have created the service pistrong-iptables-load, but it is not enabled"
    echo "** If you have another way to load iptables, you must add the code from $catables to it"
    echo "** Otherwise you must 'sudo systemctl enable --now pistrong-iptables-load'"
}
    
function writemakeCAlog() {
    local dt=$(date +"%Y-%m-%d %H:%M:%S")
    local calog="/etc/swanctl/pistrong/makeCA.log"
    [ -f $calog.bak ] && rm -f $calog.bak
    [ -f $calog ] && mv $calog $calog.bak
    cat >> $calog <<EOF
date:          $dt
version:       $version
thisfqdn:      $thisfqdn
vpnaddr:       $vpnaddr
vpndev:        $vpndev
landev:        $landev
myipaddr:      $myipaddr
mysubnetx:     $mysubnetx
myfullsubnet:  $myfullsubnet
vpnsubnet:     $vpnsubnet
vpndns:        $vpndns
cnsuffix:      $cnsuffix
webdir:        $webdir
weburl:        $weburl
san2:          $san2
ios:           $ios
ioskey:        $ioskey
windows:       $windows
winkey:        $winkey
linux:         $linux
linuxkey:      $linuxkey
EOF
}

cmd=$0
[[ $EUID -ne 0 ]] && errexit "? Please rerun: 'sudo $cmd'"
dbl=""
thishost=$(hostname)        #This gets the hostname from Linux
webdir="/var/www/html/vpn"
ios="ios"
windows="windows"
linux="linux"
caconf="/etc/swanctl/conf.d/pistrong-CAServerConnection.conf"
catables="/etc/swanctl/pistrong/CA-iptables"
[ -f $caconf ] && echo "? There is already a CA on this system" && errexit "  Use 'sudo pistrong deleteca' to delete it if you really want to recreate it"

echo "Build a prescriptive strongSwan CA for iOS, Windows, and Linux devices"
echo ""
echo "** You will be asked a series of configuration questions"
echo "   You will be prompted before any changes are made to your system"
echo "   Network configuration details are required to complete this script"
echo ""
echo "   NOTE: Although this script can accomodate multiple network adapters"
echo "         on the system, it is not really network adapter aware."
echo ""
echo "** The CA requires a domain name"
echo "   If you have a registered domain name to use for the VPN, use that"
echo "   If not, you can use a name of your choice"
echo "   NOTE: This must be a DNS name, not an IP address"
echo "         If you are using DDNS, use that domain name (e.g., myddns.ddns.net)"
echo "         See https://github.com/gitbls/pistrong for details"
echo ""
askdefault "Domain Name to use" thisdomain "noname.com"
thisfqdn="$thishost.$thisdomain"
ioskey="ios.$thisdomain"
winkey="windows.$thisdomain"
linuxkey="linux.$thisdomain"
weburl="http://$thisfqdn/vpn"

echo ""
echo "** Configuring strongSwan for host FQDN $thisfqdn"
while [ 0 ]
do
    echo ""
    echo "** DNS name or IP address that VPN clients will use when connecting to the VPN Server"
    echo "   Use your externally available DNS name if you have one, otherwise use your Internet IP address"
    echo ""
    askdefault "VPN DNS Name or IP Address for your VPN" vpnaddr "$thisfqdn"
    isipaddr $vpnaddr && break
    isdomain $vpnaddr && break
    echo "? '$vpnaddr' is neither a valid IP Address nor DNS name"
done

while [ 0 ]
do
    echo ""
    echo "** Name of the network device connected to the Internet"
    echo "   If your system has:"
    echo "    One network device: Use that device"
    echo "    > 1 network device: Use the device that is or will be connected to the Internet"
    echo "                        either directly or indirectly through a router"
    echo ""
    askdefault "Name of network device connected to the Internet" vpndev "eth0"
    isnic $vpndev && break
    echo "? '$vpndev' is not a valid network device name on this system"
done

while [ 0 ]
do
    echo ""
    echo "** Name of the network device connected to the local LAN"
    echo "   If your system has:"
    echo "    One network device:  Use that device"
    echo "    > 1 network device:  Use the device that is not '$vpndev'"
    echo ""
    askdefault "Name of network device connected to the local LAN" landev "eth0"
    isnic $landev && break
    echo "? '$landev' is not a valid network device name on this system"
done

# Get LAN IP address and subnet information from ip command
ipline="$(ip -o -f inet addr show dev $landev)"
[ "$ipline" == "" ] && errexit "? Cannot determine IP address for network device '$landev'"
ipaddr="$(echo $ipline | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\/[0-9]{1,2}')"  # Gets xx.xx.xx.xx/xx
myipaddr=${ipaddr%%/*}            # Get IP address w/o /xx
maskbits=${ipaddr##$myipaddr/}  # Get xx from /xx
subnetbrd=$(read f1 f2 f3 f4 f5 f6 f7 <<< $(echo "$ipline"); echo $f6) # Get xx.xx.xx.255
mysubnetx=${subnetbrd%.255}       # Strip the .255
myfullsubnet="${mysubnetx}.0/$maskbits" # ... and add ".0/xx"
# myipaddr=<ip address>, maskbits=<width of mask in bits>, subnetbrd=<broadcast mask (xx.xx.xx.255)>
# mysubnetx=<xx.xx.xx subnet>, myfullsubnet="<xx.xx.xx.0>/xx"

echo ""
echo "** VPN Server IP configuration"
while [ 0 ]
do
    echo "** Local LAN IP Address"
    echo "   If your system has:"
    echo "    One network device: Use the IP Address of that device"
    echo "    > 1 network device: Use the IP Address of '$landev'"
    echo ""
    askdefault "VPN Server Local LAN IP Address" tmyipaddr "$myipaddr"
    isipaddr $tmyipaddr && break
    echo "? '$tmyipaddr' is not a valid IP Address"
done

if [ "$tmyipaddr" != "$myipaddr" ]
then
    #  set mysubnetx, myfullsubnet 
    mysubnetx=${tmyipaddr%.*}
    myfullsubnet="${mysubnetx}.0/24"         #This is not perfectly correct
    myipaddr=$tmyipaddr
fi
#

while [ 0 ]
do
    echo ""
    echo "** Local LAN Subnet"
    echo "   If your system has:"
    echo "    One network device: Use the Subnet of that device"
    echo "    > 1 network device: Use the Subnet of '$landev'"
    echo ""
    askdefault "VPN Server Local LAN Subnet" mysubnet "$myfullsubnet"
    issubnet $mysubnet && break
    echo "? '$mysubnet' is not a valid LAN Subnet"
done
myfullsubnet=$mysubnet

if [ "$vpndev" != "$landev" ]
then
    ipline="$(ip -o -f inet addr show | grep $vpndev)"
    [ "$ipline" == "" ] && errexit "? Network device '$vpndev' does not have an IP Address"
    emyipaddr="$(echo $ipline | grep -oE '[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\/[0-9]{1,2}')"
    emyipaddr=${emyipaddr%%/*}
    while [ 0 ]
    do
	echo ""
	echo "** VPN Server Internet-connected network device ($vpndev) IP address"
	askdefault "VPN Server Internet-connected network device ($vpndev) IP address" emyipaddr "$emyipaddr"
	isipaddr $emyipaddr && break
	echo "? '$emyipaddr' is not a valid IP Address"
    done
else
    emyipaddr=$myipaddr
fi

while [ 0 ]
do
    echo ""
    echo "** The Subnet for VPN Clients is a virtual subnet used between"
    echo "   the VPN Server and Clients. It must not be used on your network"
    echo "   and requires iptables configuration, which will be created"
    echo "   by this script (You will need to enable it)"
    echo ""
    askdefault "Subnet for VPN Clients" vpnsubnet "10.1.10.0/24"
    issubnet $vpnsubnet && break
    echo "? '$vpnsubnet' is not a valid subnet for VPN Clients"
done

while [ 0 ]
do
    # Default to subnet.1 for DNS, since that's where most people's routers are
    echo ""
    echo "** The DNS Server should be a DNS Server on your network"
    echo "   This can be your router (if so configured) or other DNS Server"
    echo ""
    askdefault "DNS Server for connected VPN Clients" vpndns "${mysubnetx}.1"
    isipaddr $vpndns && break
    echo "? '$vpndns' is not a valid IP Address"
done

echo ""
echo "** Common Name (CN) string only used in user certs"
echo "   (e.g., username-device-$thishost@cnsuffix)"
echo "   It is used by iOS for additional Cert validation"
echo "   and will be visible for strongSwan connections in the system log"
echo ""
askdefault "Common Name (CN) suffix for your CA" cnsuffix "myvpn.net"

echo ""
echo "** File system directory where certs will be shared via your web server"
echo ""
askdefault "webdir for your system" webdir "$webdir"
[ ! -d $webdir ] && echo "% Directory $webdir does not exist. Be sure to create it before using pistrong --mail"

echo ""
echo "** URL that will be used in emails to users with their certs"
echo ""
askdefault "weburl for your system" weburl "$weburl"

echo ""
echo "** Configure the SAN Key (remoteid) and VPN Cert name for iOS, Windows, and Linux users"
echo "   The VPN Cert name prefix is important because it helps you retain your sanity"
echo "   The remoteid identifies the connection to strongSwan, and is assigned to users when they are added"
echo "   The defaults are acceptable, but you may change them if you wish"
echo ""
askdefault "VPN Cert name prefix for iOS VPN Cert" ios "$ios"
askdefault "VPN SAN key for iOS users" ioskey "$ioskey"

askdefault "VPN Cert name prefix for Windows VPN Cert" windows "$windows"
# Get Windows VPN SAN Key even though Windows IPSec stack at least as of Win10 1903 doesn't use it
askdefault "VPN SAN key for Windows users" winkey "$winkey"

askdefault "VPN Cert name prefix for Linux VPN Cert" linux "$linux"
askdefault "VPN SAN key for Linux users" linuxkey "$linuxkey"

echo ""
if isipaddr "$vpnaddr"
then
    dsan="$vpnaddr,$thisfqdn"
else
    [ "$thisfqdn" == "$vpnaddr" ] && dsan=$thisfqdn || dsan="$thisfqdn,$vpnaddr"
fi
echo "** The default secondary VPN SAN Key is '$dsan'"
echo "   You can add additional SAN Keys if desired"
echo ""
askdefault "Additional Secondary VPN SAN Key(s)" san2 ""
[ "$san2" == "" ] && san2="$dsan" || san2="$dsan,$san2"

echo ""
echo "** This script will now create:"
echo "      Connection Config:    $caconf"
echo "      CA Cert:              strongSwanCACert.pem"
echo "      VPN Cert for iOS:     $ios-strongSwanVPNCert.pem with VPN SAN key '$ioskey'"
echo "      VPN Cert for Windows: $windows-strongSwanVPNCert.pem with VPN SAN key '$winkey'"
echo "      VPN Cert for Linux:   $linux-strongSwanVPNCert.pem with VPN SAN key '$linuxkey'"
echo ""
echo "   For VPN Server LAN IP $myipaddr subnet $myfullsubnet with VPN Client DNS servers $vpndns"
echo ""
echo "   The VPN will use virtual subnet $vpnsubnet for VPN Clients"
echo ""
echo "   Each VPN cert will have '$san2' as secondary VPN SAN key(s)"
echo ""
echo "   The default VPN Server Address is '$vpnaddr'"
echo "   This can be changed on a per-user basis on the 'sudo pistrong add' command for a single user"
echo "    using the --vpnaddr new-vpn-address switch"
echo "    (You might want to do this, for example, if you're using an IP address to connect externally"
echo "     but also want to test connecting to the VPN server from your internal network)"
echo "   See https://github.com/gitbls/pistrong/blob/master/README.md"
echo "    for additional VPN Server IP Address considerations"
echo ""
echo "See 'sudo pistrong config --list' for a list of all the pistrong configuration parameters"
echo " and make any changes necessary for your configuration"
echo ""
echo "** If you'd like to change anything, answer N to the next question and restart the script"
echo ""

if ! askyn "Do you want to continue"
then
    exit
fi
#
# Set hostname in apache config as a convenience, and make sure that the $webdir directory exists
#
if [ -d /etc/apache2/conf-enabled ];
then
    if [ ! -f /etc/apache2/conf-enabled/servername.conf ]
    then
	echo "ServerName $thisfqdn" > /etc/apache2/conf-enabled/servername.conf
    fi
    [ ! -d $webdir ] && mkdir -p $webdir
fi

pistrong config --myfqdn $thisfqdn
pistrong config --vpnaddr $vpnaddr
pistrong config --cnsuffix $cnsuffix --mailfrom "PiStrongVPN<root@$thisfqdn>"
pistrong config --webdir $webdir --weburl $weburl
# This sets the default SAN Key (remoteid) for the add command
pistrong config --vpnsankey $ioskey --vpncertpfx $ios

# Make the CA and VPN certs (one for each: iOS, Windows, and Linux)
pistrong createca --nocamsg --novpncert
pistrong makevpncert $ios --vpnsankey $ioskey,$san2
pistrong makevpncert $windows --vpnsankey $winkey,$san2
pistrong makevpncert $linux --vpnsankey $linuxkey,$san2

echo ""
echo "When adding iOS     users apply --remoteid $ioskey"
echo "When adding Windows users apply --remoteid $winkey"
echo "When adding Linux   users apply --remoteid $linuxkey --linux"
echo ""
echo "Your strongSwan CA is configured"
echo ""
echo "Creating $catables with firewall rules"
emitFirewall
echo ""
echo "Creating $caconf with the new VPN Server definitions"
updowns="/usr/lib/ipsec/_updown"
# If $updowns not found we were built from tarball, so use alternate location
[ ! -f $updowns ] && updowns="/libexec/ipsec/_updown"
cat > $caconf <<EOF
connections {
    linux-pubkey-ikev2 {
        version = 2
        proposals = aes192gcm16-aes128gcm16-prfsha256-ecp256-ecp521,aes192-sha256-modp3072,default
        rekey_time = 0s
        pools = primary-pool-ipv4
        fragmentation = yes
        local-1 {
             auth = pubkey
             cacerts = strongSwanCACert.pem
             certs = $linux-strongSwanVPNCert.pem
             id = $linuxkey
        }
        remote-1 {
             auth = pubkey
        }
        children {
            net-linux {
                remote_ts = $vpnsubnet
                local_ts = $myfullsubnet
                updown = $updowns iptables
		esp_proposals = aes128gcm128-x25519
            }
        }
    }
    ios-pubkey-ikev2 {
        version = 2
        proposals = aes256-sha1-modp1024,aes192-sha256-modp3072,aes128-sha1-modp1536,aes128-sha256-modp1536,aes128-sha256-modp2048,default
        rekey_time = 0s
        pools = primary-pool-ipv4
        fragmentation = no
        dpd_delay = 30s
        send_cert = always

        local-1 {
             auth = pubkey
             cacerts = strongSwanCACert.pem
             certs = $ios-strongSwanVPNCert.pem
             id = $ioskey
        }

        remote-1 {
             auth = eap-tls
             id = %any
        }

        children {
             net-ios {
                 local_ts = 0.0.0.0/0
                 rekey_time = 0s
                 dpd_action = clear
                 esp_proposals = aes256-sha1-modp1024,aes192-sha256-modp3072,aes128-sha1-modp1536,aes128-sha256-modp1536,aes128-sha256-modp2048,default
             }
        }
    }
    windows-pubkey-ikev2 {
        version = 2
        proposals = aes256-sha1-modp1024,aes192-sha256-modp3072,default
        rekey_time = 0s
        pools = primary-pool-ipv4
        fragmentation = yes
        dpd_delay = 30s

        local-1 {
             auth = pubkey
             cacerts = strongSwanCACert.pem
             certs = $windows-strongSwanVPNCert.pem
             id = $winkey
        }

        remote-1 {
             id = %any
        }

        children {
             net-windows {
                 local_ts = 0.0.0.0/0
                 rekey_time = 0s
                 dpd_action = clear
                 esp_proposals = aes256-sha1-modp1024,aes192-sha256-modp3072,default
             }
        }
    }
}
    pools {
    primary-pool-ipv4 {
        addrs = $vpnsubnet
        dns = $vpndns
    }
}
EOF

writemakeCAlog

echo ""
echo " ** Next steps:"
echo "    * Ensure that the firewall rules in $catables are correct"
echo "    * Review and follow https://github.com/gitbls/pistrong/blob/master/README.md#firewall-considerations"
echo "    * Establish port forwarding on your router to IP $emyipaddr for UDP ports 500 and 4500"
echo "    * Set up a mail server and web server if you want to email cert information to users"
echo ""
